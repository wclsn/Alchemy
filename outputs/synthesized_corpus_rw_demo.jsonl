{"file_name": "Mathlib/Algebra/IsPrimePow.lean", "original_text": "/-\nCopyright (c) 2022 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\nimport Mathlib.Algebra.Associated\nimport Mathlib.NumberTheory.Divisors\n\n#align_import algebra.is_prime_pow from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n/-!\n# Prime powers\n\nThis file deals with prime powers: numbers which are positive integer powers of a single prime.\n-/\n\n\nvariable {R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)\n\n/-- `n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. -/\ndef IsPrimePow : Prop :=\n  \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n\n#align is_prime_pow IsPrimePow\n\ntheorem isPrimePow_def : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n :=\n  Iff.rfl\n#align is_prime_pow_def isPrimePow_def\n\n/-- An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a\nnatural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem isPrimePow_iff_pow_succ : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 p ^ (k + 1) = n :=\n  (isPrimePow_def _).trans\n    \u27e8fun \u27e8p, k, hp, hk, hn\u27e9 => \u27e8_, _, hp, by rwa [Nat.sub_add_cancel hk]\u27e9, fun \u27e8p, k, hp, hn\u27e9 =>\n      \u27e8_, _, hp, Nat.succ_pos', hn\u27e9\u27e9\n#align is_prime_pow_iff_pow_succ isPrimePow_iff_pow_succ\n\ntheorem not_isPrimePow_zero [NoZeroDivisors R] : \u00acIsPrimePow (0 : R) := by\n  simp only [isPrimePow_def, not_exists, not_and', and_imp]\n  intro x n _hn hx\n  rw [pow_eq_zero hx]\n  simp\n#align not_is_prime_pow_zero not_isPrimePow_zero\n\ntheorem IsPrimePow.not_unit {n : R} (h : IsPrimePow n) : \u00acIsUnit n :=\n  let \u27e8_p, _k, hp, hk, hn\u27e9 := h\n  hn \u25b8 (isUnit_pow_iff hk.ne').not.mpr hp.not_unit\n#align is_prime_pow.not_unit IsPrimePow.not_unit\n\ntheorem IsUnit.not_isPrimePow {n : R} (h : IsUnit n) : \u00acIsPrimePow n := fun h' => h'.not_unit h\n#align is_unit.not_is_prime_pow IsUnit.not_isPrimePow\n\ntheorem not_isPrimePow_one : \u00acIsPrimePow (1 : R) :=\n  isUnit_one.not_isPrimePow\n#align not_is_prime_pow_one not_isPrimePow_one\n\ntheorem Prime.isPrimePow {p : R} (hp : Prime p) : IsPrimePow p :=\n  \u27e8p, 1, hp, zero_lt_one, by simp\u27e9\n#align prime.is_prime_pow Prime.isPrimePow\n\ntheorem IsPrimePow.pow {n : R} (hn : IsPrimePow n) {k : \u2115} (hk : k \u2260 0) : IsPrimePow (n ^ k) :=\n  let \u27e8p, k', hp, hk', hn\u27e9 := hn\n  \u27e8p, k * k', hp, mul_pos hk.bot_lt hk', by rw [pow_mul', hn]\u27e9\n#align is_prime_pow.pow IsPrimePow.pow\n\ntheorem IsPrimePow.ne_zero [NoZeroDivisors R] {n : R} (h : IsPrimePow n) : n \u2260 0 := fun t =>\n  not_isPrimePow_zero (t \u25b8 h)\n#align is_prime_pow.ne_zero IsPrimePow.ne_zero\n\ntheorem IsPrimePow.ne_one {n : R} (h : IsPrimePow n) : n \u2260 1 := fun t =>\n  not_isPrimePow_one (t \u25b8 h)\n#align is_prime_pow.ne_one IsPrimePow.ne_one\n\nsection Nat\n\ntheorem isPrimePow_nat_iff (n : \u2115) : IsPrimePow n \u2194 \u2203 p k : \u2115, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n := by\n  simp only [isPrimePow_def, Nat.prime_iff]\n#align is_prime_pow_nat_iff isPrimePow_nat_iff\n\ntheorem Nat.Prime.isPrimePow {p : \u2115} (hp : p.Prime) : IsPrimePow p :=\n  _root_.Prime.isPrimePow (prime_iff.mp hp)\n#align nat.prime.is_prime_pow Nat.Prime.isPrimePow\n\ntheorem isPrimePow_nat_iff_bounded (n : \u2115) :\n    IsPrimePow n \u2194 \u2203 p : \u2115, p \u2264 n \u2227 \u2203 k : \u2115, k \u2264 n \u2227 p.Prime \u2227 0 < k \u2227 p ^ k = n := by\n  rw [isPrimePow_nat_iff]\n  refine' Iff.symm \u27e8fun \u27e8p, _, k, _, hp, hk, hn\u27e9 => \u27e8p, k, hp, hk, hn\u27e9, _\u27e9\n  rintro \u27e8p, k, hp, hk, rfl\u27e9\n  refine' \u27e8p, _, k, (Nat.lt_pow_self hp.one_lt _).le, hp, hk, rfl\u27e9\n  conv => { lhs; rw [\u2190 (pow_one p)] }\n  exact pow_le_pow_right hp.one_lt.le hk\n#align is_prime_pow_nat_iff_bounded isPrimePow_nat_iff_bounded\n\ninstance {n : \u2115} : Decidable (IsPrimePow n) :=\n  decidable_of_iff' _ (isPrimePow_nat_iff_bounded n)\n\ntheorem IsPrimePow.dvd {n m : \u2115} (hn : IsPrimePow n) (hm : m \u2223 n) (hm\u2081 : m \u2260 1) : IsPrimePow m := by\n  rw [isPrimePow_nat_iff] at hn \u22a2\n  rcases hn with \u27e8p, k, hp, _hk, rfl\u27e9\n  obtain \u27e8i, hik, rfl\u27e9 := (Nat.dvd_prime_pow hp).1 hm\n  refine' \u27e8p, i, hp, _, rfl\u27e9\n  apply Nat.pos_of_ne_zero\n  rintro rfl\n  simp only [pow_zero, ne_eq, not_true_eq_false] at hm\u2081\n#align is_prime_pow.dvd IsPrimePow.dvd\n\ntheorem Nat.disjoint_divisors_filter_isPrimePow {a b : \u2115} (hab : a.Coprime b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n#align nat.disjoint_divisors_filter_prime_pow Nat.disjoint_divisors_filter_isPrimePow\n\ntheorem IsPrimePow.two_le : \u2200 {n : \u2115}, IsPrimePow n \u2192 2 \u2264 n\n  | 0, h => (not_isPrimePow_zero h).elim\n  | 1, h => (not_isPrimePow_one h).elim\n  | _n + 2, _ => le_add_self\n#align is_prime_pow.two_le IsPrimePow.two_le\n\ntheorem IsPrimePow.pos {n : \u2115} (hn : IsPrimePow n) : 0 < n :=\n  pos_of_gt hn.two_le\n#align is_prime_pow.pos IsPrimePow.pos\n\ntheorem IsPrimePow.one_lt {n : \u2115} (h : IsPrimePow n) : 1 < n :=\n  h.two_le\n#align is_prime_pow.one_lt IsPrimePow.one_lt\n\nend Nat\n", "text": "/-\nCopyright (c) 2022 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\nimport Mathlib.Algebra.Associated\nimport Mathlib.NumberTheory.Divisors\n\n#align_import algebra.is_prime_pow from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n/-!\n# Prime powers\n\nThis file deals with prime powers: numbers which are positive integer powers of a single prime.\n-/\n\n\nvariable {R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)\n\n/-- `n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. -/\ndef IsPrimePow : Prop :=\n  \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n\n#align is_prime_pow IsPrimePow\n\ntheorem isPrimePow_def : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n :=\n  Iff.rfl\n#align is_prime_pow_def isPrimePow_def\n\n/-- An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a\nnatural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem isPrimePow_iff_pow_succ : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 p ^ (k + 1) = n :=\n  (isPrimePow_def _).trans\n    \u27e8fun \u27e8p, k, hp, hk, hn\u27e9 => \u27e8_, _, hp, by rwa [Nat.sub_add_cancel hk]\u27e9, fun \u27e8p, k, hp, hn\u27e9 =>\n      \u27e8_, _, hp, Nat.succ_pos', hn\u27e9\u27e9\n#align is_prime_pow_iff_pow_succ isPrimePow_iff_pow_succ\n\ntheorem not_isPrimePow_zero [NoZeroDivisors R] : \u00acIsPrimePow (0 : R) := by\n  simp only [isPrimePow_def, not_exists, not_and', and_imp]\n  intro x n _hn hx\n  rw [pow_eq_zero hx]\n  simp\n#align not_is_prime_pow_zero not_isPrimePow_zero\n\ntheorem IsPrimePow.not_unit {n : R} (h : IsPrimePow n) : \u00acIsUnit n :=\n  let \u27e8_p, _k, hp, hk, hn\u27e9 := h\n  hn \u25b8 (isUnit_pow_iff hk.ne').not.mpr hp.not_unit\n#align is_prime_pow.not_unit IsPrimePow.not_unit\n\ntheorem IsUnit.not_isPrimePow {n : R} (h : IsUnit n) : \u00acIsPrimePow n := fun h' => h'.not_unit h\n#align is_unit.not_is_prime_pow IsUnit.not_isPrimePow\n\ntheorem not_isPrimePow_one : \u00acIsPrimePow (1 : R) :=\n  isUnit_one.not_isPrimePow\n#align not_is_prime_pow_one not_isPrimePow_one\n\ntheorem Prime.isPrimePow {p : R} (hp : Prime p) : IsPrimePow p :=\n  \u27e8p, 1, hp, zero_lt_one, by simp\u27e9\n#align prime.is_prime_pow Prime.isPrimePow\n\ntheorem IsPrimePow.pow {n : R} (hn : IsPrimePow n) {k : \u2115} (hk : k \u2260 0) : IsPrimePow (n ^ k) :=\n  let \u27e8p, k', hp, hk', hn\u27e9 := hn\n  \u27e8p, k * k', hp, mul_pos hk.bot_lt hk', by rw [pow_mul', hn]\u27e9\n#align is_prime_pow.pow IsPrimePow.pow\n\ntheorem IsPrimePow.ne_zero [NoZeroDivisors R] {n : R} (h : IsPrimePow n) : n \u2260 0 := fun t =>\n  not_isPrimePow_zero (t \u25b8 h)\n#align is_prime_pow.ne_zero IsPrimePow.ne_zero\n\ntheorem IsPrimePow.ne_one {n : R} (h : IsPrimePow n) : n \u2260 1 := fun t =>\n  not_isPrimePow_one (t \u25b8 h)\n#align is_prime_pow.ne_one IsPrimePow.ne_one\n\nsection Nat\n\ntheorem isPrimePow_nat_iff (n : \u2115) : IsPrimePow n \u2194 \u2203 p k : \u2115, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n := by\n  simp only [isPrimePow_def, Nat.prime_iff]\n#align is_prime_pow_nat_iff isPrimePow_nat_iff\n\ntheorem Nat.Prime.isPrimePow {p : \u2115} (hp : p.Prime) : IsPrimePow p :=\n  _root_.Prime.isPrimePow (prime_iff.mp hp)\n#align nat.prime.is_prime_pow Nat.Prime.isPrimePow\n\ntheorem isPrimePow_nat_iff_bounded (n : \u2115) :\n    IsPrimePow n \u2194 \u2203 p : \u2115, p \u2264 n \u2227 \u2203 k : \u2115, k \u2264 n \u2227 p.Prime \u2227 0 < k \u2227 p ^ k = n := by\n  rw [isPrimePow_nat_iff]\n  refine' Iff.symm \u27e8fun \u27e8p, _, k, _, hp, hk, hn\u27e9 => \u27e8p, k, hp, hk, hn\u27e9, _\u27e9\n  rintro \u27e8p, k, hp, hk, rfl\u27e9\n  refine' \u27e8p, _, k, (Nat.lt_pow_self hp.one_lt _).le, hp, hk, rfl\u27e9\n  conv => { lhs; rw [\u2190 (pow_one p)] }\n  exact pow_le_pow_right hp.one_lt.le hk\n#align is_prime_pow_nat_iff_bounded isPrimePow_nat_iff_bounded\n\ninstance {n : \u2115} : Decidable (IsPrimePow n) :=\n  decidable_of_iff' _ (isPrimePow_nat_iff_bounded n)\n\ntheorem IsPrimePow.dvd {n m : \u2115} (hn : IsPrimePow n) (hm : m \u2223 n) (hm\u2081 : m \u2260 1) : IsPrimePow m := by\n  rw [isPrimePow_nat_iff] at hn \u22a2\n  rcases hn with \u27e8p, k, hp, _hk, rfl\u27e9\n  obtain \u27e8i, hik, rfl\u27e9 := (Nat.dvd_prime_pow hp).1 hm\n  refine' \u27e8p, i, hp, _, rfl\u27e9\n  apply Nat.pos_of_ne_zero\n  rintro rfl\n  simp only [pow_zero, ne_eq, not_true_eq_false] at hm\u2081\n#align is_prime_pow.dvd IsPrimePow.dvd\n\ntheorem Nat.disjoint_divisors_filter_isPrimePow {a b : \u2115} (hab : a.Coprime b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\n\nexample {a b : \u2115} (hab : gcd a b = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [\u2190Nat.coprime_iff_gcd_eq_one] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : Coprime b a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [\u2190Nat.coprime_comm] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : Coprime b a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [Nat.coprime_comm] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : Coprime a (b + a)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [Nat.coprime_add_self_right] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : Coprime a (a + b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [Nat.coprime_self_add_right] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : Coprime (a + b) b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [Nat.coprime_add_self_left] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : Coprime (b + a) b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [Nat.coprime_self_add_left] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : IsRelPrime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by rw [\u2190Nat.coprime_iff_isRelPrime] at hab;exact hab\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        (Disjoint on fun c => bif c then Finset.filter IsPrimePow (divisors a) else Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190pairwise_disjoint_on_bool] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        (Finset.filter IsPrimePow (divisors a)).card + (Finset.filter IsPrimePow (divisors b)).card:= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Finset.card_union_eq_card_add_card] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        (Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Finset.subtype_map] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     \u2200 \u2983a_1 : \u2115\u2984, a_1 \u2208 Finset.filter IsPrimePow (divisors a) \u2192 a_1 \u2209 Finset.filter IsPrimePow (divisors b):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [Finset.disjoint_left] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     \u2200 \u2983a_1 : \u2115\u2984, a_1 \u2208 Finset.filter IsPrimePow (divisors b) \u2192 a_1 \u2209 Finset.filter IsPrimePow (divisors a):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [Finset.disjoint_right] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     \u2200 a_1 \u2208 Finset.filter IsPrimePow (divisors a), \u2200 b_1 \u2208 Finset.filter IsPrimePow (divisors b), a_1 \u2260 b_1:= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [Finset.disjoint_iff_ne] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Multiset.Disjoint (Finset.filter IsPrimePow (divisors a)).val (Finset.filter IsPrimePow (divisors b)).val:= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Finset.disjoint_val] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Disjoint \u2191(Finset.filter IsPrimePow (divisors a)) \u2191(Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Finset.disjoint_coe] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Finset.filter IsPrimePow (divisors a) \u2229 Finset.filter IsPrimePow (divisors b) = \u2205:= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [Finset.disjoint_iff_inter_eq_empty] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Finset.filter IsPrimePow (divisors a) \\ Finset.filter IsPrimePow (divisors b) = Finset.filter IsPrimePow (divisors a):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Finset.sdiff_eq_self_iff_disjoint] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [Finset.filter_congr_decidable] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Finset.filter IsPrimePow (divisors a) \\ Finset.filter IsPrimePow (divisors b) = Finset.filter IsPrimePow (divisors a):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190sdiff_eq_left] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Finset.filter IsPrimePow (divisors b) \\ Finset.filter IsPrimePow (divisors a) = Finset.filter IsPrimePow (divisors b):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190sdiff_eq_self_iff_disjoint] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Finset.filter IsPrimePow (divisors a) \\ Finset.filter IsPrimePow (divisors b) = Finset.filter IsPrimePow (divisors a):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190sdiff_eq_self_iff_disjoint'] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Disjoint (Finset.filter IsPrimePow (divisors b)) (Finset.filter IsPrimePow (divisors a)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [disjoint_comm] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Disjoint (Finset.filter IsPrimePow (divisors b)) (Finset.filter IsPrimePow (divisors a)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190disjoint_comm] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Finset.filter IsPrimePow (divisors a) \u2293 Finset.filter IsPrimePow (divisors b) \u2264 \u22a5:= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [disjoint_iff_inf_le] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n     Finset.filter IsPrimePow (divisors a) \u2293 Finset.filter IsPrimePow (divisors b) = \u22a5:= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [disjoint_iff] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        Finset.filter IsPrimePow (divisors a) \u2294 Finset.filter IsPrimePow (divisors b):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190symmDiff_eq_sup] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        symmDiff (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190le_symmDiff_iff_left] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        symmDiff (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190le_symmDiff_iff_right] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        (Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Nat.image_fst_divisorsAntidiagonal] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        (Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Nat.image_snd_divisorsAntidiagonal] at this;exact this\n\nexample {a b : \u2115} (hab : a.Coprime b) :\n        (Finset.filter IsPrimePow (divisors b)):= by\n  have : Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by \n    simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n    rintro n han _ha hn hbn _hb -\n    exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n  rw [\u2190Nat.image_div_divisors_eq_divisors] at this;exact this\n#align nat.disjoint_divisors_filter_prime_pow Nat.disjoint_divisors_filter_isPrimePow\n\ntheorem IsPrimePow.two_le : \u2200 {n : \u2115}, IsPrimePow n \u2192 2 \u2264 n\n  | 0, h => (not_isPrimePow_zero h).elim\n  | 1, h => (not_isPrimePow_one h).elim\n  | _n + 2, _ => le_add_self\n#align is_prime_pow.two_le IsPrimePow.two_le\n\ntheorem IsPrimePow.pos {n : \u2115} (hn : IsPrimePow n) : 0 < n :=\n  pos_of_gt hn.two_le\n#align is_prime_pow.pos IsPrimePow.pos\n\ntheorem IsPrimePow.one_lt {n : \u2115} (h : IsPrimePow n) : 1 < n :=\n  h.two_le\n#align is_prime_pow.one_lt IsPrimePow.one_lt\n\nend Nat", "valid_loc": {"Nat.disjoint_divisors_filter_isPrimePow": [[163, 168]]}, "loc": {"Nat.disjoint_divisors_filter_isPrimePow": [[114, 119], [121, 126], [128, 133], [135, 140], [142, 147], [149, 154], [156, 161], [163, 168], [170, 176], [178, 184], [186, 192], [194, 200], [202, 208], [210, 216], [218, 224], [226, 232], [234, 240], [242, 248], [250, 256], [258, 264], [266, 272], [274, 280], [282, 288], [290, 296], [298, 304], [306, 312], [314, 320], [322, 328], [330, 336], [338, 344], [346, 352], [354, 360]]}, "meta": "https://github.com/leanprover-community/mathlib4/commit/3c307701fa7e9acbdc0680d7f3b9c9fed9081740"}
