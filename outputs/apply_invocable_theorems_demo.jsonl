{"Nat.dvd_antisymm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2223 gcd a b", "rule": "have hab : a.Coprime b := by apply Nat.dvd_antisymm"}], "hypo_name": [["hab"]]}
{"Nat.eq_one_of_dvd_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 1", "rule": "have hab : a.Coprime b := by apply Nat.eq_one_of_dvd_one"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.gcd_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a b", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.gcd_eq_one"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.symm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime b a", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.symm"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.coprime_dvd_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2223 ?k\n\ncase H2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime ?k b\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.coprime_dvd_left"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.coprime_dvd_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2223 ?m\n\ncase H2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?m\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.coprime_dvd_right"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.coprime_mul_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime (?k * a) b\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_left"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.coprime_mul_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime (a * ?k) b\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_right"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.coprime_mul_left_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a (?k * b)\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_left_right"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.coprime_mul_right_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a (b * ?k)\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_right_right"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.eq_one_of_dvd": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime (gcd a b) ?m\n\ncase d\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 ?m\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.eq_one_of_dvd"}], "hypo_name": [["hab"]]}
{"List.rel_of_pairwise_cons": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Pairwise Coprime (a :: ?l)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.rel_of_pairwise_cons"}], "hypo_name": [["hab"]]}
{"List.Pairwise.forall_of_forall_of_flip": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?l, Coprime x x\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Pairwise Coprime ?l\n\ncase h\u2083\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Pairwise (flip Coprime) ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Pairwise.forall_of_forall_of_flip"}], "hypo_name": [["hab"]]}
{"Option.mem_unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?o\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?o\n\ncase o\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Option \u2115", "rule": "have hab : a.Coprime b := by apply Option.mem_unique"}], "hypo_name": [["hab"]]}
{"List.head_eq_of_cons_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b :: ?t\u2081 = 1 :: ?t\u2082\n\ncase t\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115\n\ncase t\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.head_eq_of_cons_eq"}], "hypo_name": [["hab"]]}
{"List.eq_of_mem_singleton": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 [1]", "rule": "have hab : a.Coprime b := by apply List.eq_of_mem_singleton"}], "hypo_name": [["hab"]]}
{"List.last_eq_of_concat_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.concat ?l (gcd a b) = List.concat ?l 1\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.last_eq_of_concat_eq"}], "hypo_name": [["hab"]]}
{"List.forall_mem_nil": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 []", "rule": "have hab : a.Coprime b := by apply List.forall_mem_nil"}], "hypo_name": [["hab"]]}
{"List.eq_of_mem_replicate": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 List.replicate ?n 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply List.eq_of_mem_replicate"}], "hypo_name": [["hab"]]}
{"List.get?_inj": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2080\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b < List.length ?xs\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Nodup ?xs\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.get? ?xs (gcd a b) = List.get? ?xs 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.6893428\n\ncase xs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List ?\u03b1\u271d", "rule": "have hab : a.Coprime b := by apply List.get?_inj"}], "hypo_name": [["hab"]]}
{"List.rel_of_chain_cons": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Chain Coprime a (b :: ?l)\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.rel_of_chain_cons"}], "hypo_name": [["hab"]]}
{"Nat.gcd.induction": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H0\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), Coprime 0 n\n\ncase H1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (m n : \u2115), 0 < m \u2192 Coprime (n % m) m \u2192 Coprime m n", "rule": "have hab : a.Coprime b := by apply Nat.gcd.induction"}], "hypo_name": [["hab"]]}
{"Nat.eq_of_testBit_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase pred\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : \u2115), testBit (gcd a b) i = testBit 1 i", "rule": "have hab : a.Coprime b := by apply Nat.eq_of_testBit_eq"}], "hypo_name": [["hab"]]}
{"Std.RBNode.All.lowerBound?_lb": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Std.RBNode.All (Coprime a) ?t\n\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 {x : \u2115}, x \u2208 ?lb \u2192 Coprime a x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Std.RBNode.lowerBound? ?cut ?t ?lb = some b\n\ncase lb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Option \u2115\n\ncase cut\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Ordering\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Std.RBNode \u2115", "rule": "have hab : a.Coprime b := by apply Std.RBNode.All.lowerBound?_lb"}], "hypo_name": [["hab"]]}
{"Std.RBNode.All.lowerBound?": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Std.RBNode.All (Coprime a) ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Std.RBNode.lowerBound? ?cut ?t none = some b\n\ncase cut\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Ordering\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Std.RBNode \u2115", "rule": "have hab : a.Coprime b := by apply Std.RBNode.All.lowerBound?"}], "hypo_name": [["hab"]]}
{"Nat.eq_of_lt_succ_of_not_lt": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hmn\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b < 1 + 1\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acgcd a b < 1", "rule": "have hab : a.Coprime b := by apply Nat.eq_of_lt_succ_of_not_lt"}], "hypo_name": [["hab"]]}
{"Nat.eq_of_le_of_lt_succ": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b < 1 + 1", "rule": "have hab : a.Coprime b := by apply Nat.eq_of_le_of_lt_succ"}], "hypo_name": [["hab"]]}
{"Nat.pred_inj": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 < gcd a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 < 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 pred (gcd a b) = pred 1", "rule": "have hab : a.Coprime b := by apply Nat.pred_inj"}], "hypo_name": [["hab"]]}
{"Nat.mul_left_cancel": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase np\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 < ?n\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?n * gcd a b = ?n * 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.mul_left_cancel"}], "hypo_name": [["hab"]]}
{"Nat.mul_right_cancel": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase mp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 < ?m\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b * ?m = 1 * ?m\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.mul_right_cancel"}], "hypo_name": [["hab"]]}
{"of_iff_true": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a b \u2194 True", "rule": "have hab : a.Coprime b := by apply of_iff_true"}], "hypo_name": [["hab"]]}
{"imp_intro": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply imp_intro"}], "hypo_name": [["hab"]]}
{"imp_imp_imp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2080\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?c \u2192 ?a\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2192 ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply imp_imp_imp"}], "hypo_name": [["hab"]]}
{"Or.resolve_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2228 Coprime a b\n\ncase na\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Or.resolve_left"}], "hypo_name": [["hab"]]}
{"Or.neg_resolve_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?a \u2228 Coprime a b\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Or.neg_resolve_left"}], "hypo_name": [["hab"]]}
{"Or.resolve_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a b \u2228 ?b\n\ncase nb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Or.resolve_right"}], "hypo_name": [["hab"]]}
{"Or.neg_resolve_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a b \u2228 \u00ac?b\n\ncase nb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Or.neg_resolve_right"}], "hypo_name": [["hab"]]}
{"forall_imp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a_1 : \u2115), ?p a_1 \u2192 Coprime a a_1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a : \u2115), ?p a\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply forall_imp"}], "hypo_name": [["hab"]]}
{"Decidable.by_contra": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acCoprime a b \u2192 False", "rule": "have hab : a.Coprime b := by apply Decidable.by_contra"}], "hypo_name": [["hab"]]}
{"Decidable.of_not_imp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac(Coprime a b \u2192 ?b)\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Decidable.of_not_imp"}], "hypo_name": [["hab"]]}
{"Decidable.not_imp_symm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acCoprime a b \u2192 ?b\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Decidable.not_imp_symm"}], "hypo_name": [["hab"]]}
{"Decidable.peirce": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (Coprime a b \u2192 ?b) \u2192 Coprime a b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Decidable.peirce"}], "hypo_name": [["hab"]]}
{"peirce'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b_1 : Prop), (Coprime a b \u2192 b_1) \u2192 Coprime a b", "rule": "have hab : a.Coprime b := by apply peirce'"}], "hypo_name": [["hab"]]}
{"Subtype.coind_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Subtype.coind ?f ?h (gcd a b) = Subtype.coind ?f ?h 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7063120\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 Prop\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a : \u2115), ?p (?f a)", "rule": "have hab : a.Coprime b := by apply Subtype.coind_injective"}], "hypo_name": [["hab"]]}
{"PLift.up_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 { down := gcd a b } = { down := 1 }", "rule": "have hab : a.Coprime b := by apply PLift.up_injective"}], "hypo_name": [["hab"]]}
{"ULift.up_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 { down := gcd a b } = { down := 1 }", "rule": "have hab : a.Coprime b := by apply ULift.up_injective"}], "hypo_name": [["hab"]]}
{"Multiset.Pairwise.forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Symmetric Coprime\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset.Pairwise Coprime ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset \u2115", "rule": "have hab : a.Coprime b := by apply Multiset.Pairwise.forall"}], "hypo_name": [["hab"]]}
{"Multiset.inj_on_of_nodup_map": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset.Nodup (Multiset.map ?f ?s)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7088417\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset \u2115", "rule": "have hab : a.Coprime b := by apply Multiset.inj_on_of_nodup_map"}], "hypo_name": [["hab"]]}
{"Multiset.eq_of_mem_replicate": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Multiset.replicate ?n 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Multiset.eq_of_mem_replicate"}], "hypo_name": [["hab"]]}
{"Multiset.replicate_right_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hn\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?n \u2260 0\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset.replicate ?n (gcd a b) = Multiset.replicate ?n 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Multiset.replicate_right_injective"}], "hypo_name": [["hab"]]}
{"Multiset.replicate_left_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => Multiset.replicate x ?a) (gcd a b) = (fun x => Multiset.replicate x ?a) 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7094620\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1", "rule": "have hab : a.Coprime b := by apply Multiset.replicate_left_injective"}], "hypo_name": [["hab"]]}
{"Multiset.eq_of_mem_map_const": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Multiset.map (Function.const ?\u03b1 1) \u2191?l\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7096556\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List ?\u03b1", "rule": "have hab : a.Coprime b := by apply Multiset.eq_of_mem_map_const"}], "hypo_name": [["hab"]]}
{"Multiset.of_mem_filter": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 Multiset.filter (Coprime a) ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset \u2115", "rule": "have hab : a.Coprime b := by apply Multiset.of_mem_filter"}], "hypo_name": [["hab"]]}
{"Multiset.map_set_pairwise": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise {a | a \u2208 ?m} fun a\u2081 a\u2082 => Coprime (?f a\u2081) (?f a\u2082)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 {b | b \u2208 Multiset.map ?f ?m}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 {b | b \u2208 Multiset.map ?f ?m}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7105427\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset ?\u03b1", "rule": "have hab : a.Coprime b := by apply Multiset.map_set_pairwise"}], "hypo_name": [["hab"]]}
{"Nat.ModEq.eq_of_abs_lt": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2261 1 [MOD ?m]\n\ncase h2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 |\u21911 - \u2191(gcd a b)| < \u2191?m\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.ModEq.eq_of_abs_lt"}], "hypo_name": [["hab"]]}
{"Nat.ModEq.eq_of_lt_of_lt": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2261 1 [MOD ?m]\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b < ?m\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 < ?m\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.ModEq.eq_of_lt_of_lt"}], "hypo_name": [["hab"]]}
{"Nat.coprime_of_mul_modEq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a * ?b \u2261 1 [MOD b]\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.coprime_of_mul_modEq_one"}], "hypo_name": [["hab"]]}
{"Nat.pow_right_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 2 \u2264 ?x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?x ^ x) (gcd a b) = (fun x => ?x ^ x) 1\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.pow_right_injective"}], "hypo_name": [["hab"]]}
{"Nat.pow_left_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hm\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?m \u2260 0\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x ^ ?m) (gcd a b) = (fun x => x ^ ?m) 1\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.pow_left_injective"}], "hypo_name": [["hab"]]}
{"Nat.eq_of_perm_factors": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2260 0\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2260 0\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Perm (factors (gcd a b)) (factors 1)", "rule": "have hab : a.Coprime b := by apply Nat.eq_of_perm_factors"}], "hypo_name": [["hab"]]}
{"Nat.coprime_of_dvd": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (k : \u2115), Prime k \u2192 k \u2223 a \u2192 \u00ack \u2223 b", "rule": "have hab : a.Coprime b := by apply Nat.coprime_of_dvd"}], "hypo_name": [["hab"]]}
{"Nat.coprime_of_dvd'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (k : \u2115), Prime k \u2192 k \u2223 a \u2192 k \u2223 b \u2192 k \u2223 1", "rule": "have hab : a.Coprime b := by apply Nat.coprime_of_dvd'"}], "hypo_name": [["hab"]]}
{"Nat.Prime.eq_one_of_pow": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prime (?x ^ gcd a b)\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.Prime.eq_one_of_pow"}], "hypo_name": [["hab"]]}
{"Nat.coprime_of_lt_prime": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase n_pos\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 < b\n\ncase hlt\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b < a\n\ncase pp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prime a", "rule": "have hab : a.Coprime b := by apply Nat.coprime_of_lt_prime"}], "hypo_name": [["hab"]]}
{"Nat.succ_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 succ (gcd a b) = succ 1", "rule": "have hab : a.Coprime b := by apply Nat.succ_injective"}], "hypo_name": [["hab"]]}
{"Nat.eq_of_dvd_of_div_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 1\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 / gcd a b = 1", "rule": "have hab : a.Coprime b := by apply Nat.eq_of_dvd_of_div_eq_one"}], "hypo_name": [["hab"]]}
{"Nat.mod_injOn_Ico": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 \u2191(Finset.Ico ?n (?n + ?a))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u2191(Finset.Ico ?n (?n + ?a))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x % ?a) (gcd a b) = (fun x => x % ?a) 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.mod_injOn_Ico"}], "hypo_name": [["hab"]]}
{"Nat.decreasing_induction_of_not_bddAbove": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n\n\ncase hP\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acBddAbove {x | Coprime a x}", "rule": "have hab : a.Coprime b := by apply Nat.decreasing_induction_of_not_bddAbove"}], "hypo_name": [["hab"]]}
{"Nat.decreasing_induction_of_infinite": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n\n\ncase hP\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Infinite {x | Coprime a x}", "rule": "have hab : a.Coprime b := by apply Nat.decreasing_induction_of_infinite"}], "hypo_name": [["hab"]]}
{"Nat.cauchy_induction'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?seed\n\ncase hi\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?seed \u2264 x \u2192 Coprime a x \u2192 \u2203 y, x < y \u2227 Coprime a y\n\ncase seed\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.cauchy_induction'"}], "hypo_name": [["hab"]]}
{"Nat.cauchy_induction": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?seed\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?seed \u2264 x \u2192 Coprime a x \u2192 x < ?f x \u2227 Coprime a (?f x)\n\ncase seed\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.cauchy_induction"}], "hypo_name": [["hab"]]}
{"Nat.cauchy_induction_mul": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n\n\ncase hk\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 < ?k\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a (succ ?seed)\n\ncase hm\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?seed < x \u2192 Coprime a x \u2192 Coprime a (?k * x)\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase seed\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.cauchy_induction_mul"}], "hypo_name": [["hab"]]}
{"Nat.cauchy_induction_two_mul": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a (succ ?seed)\n\ncase hm\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?seed < x \u2192 Coprime a x \u2192 Coprime a (2 * x)\n\ncase seed\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.cauchy_induction_two_mul"}], "hypo_name": [["hab"]]}
{"Nat.dvd_left_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x x_1 => x \u2223 x_1) (gcd a b) = (fun x x_1 => x \u2223 x_1) 1", "rule": "have hab : a.Coprime b := by apply Nat.dvd_left_injective"}], "hypo_name": [["hab"]]}
{"Nat.eq_one_of_mul_eq_one_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b * ?n = 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.eq_one_of_mul_eq_one_right"}], "hypo_name": [["hab"]]}
{"Nat.eq_one_of_mul_eq_one_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?m * gcd a b = 1\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.eq_one_of_mul_eq_one_left"}], "hypo_name": [["hab"]]}
{"Nat.diag_induction": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a : \u2115), Coprime (a + 1) (a + 1)\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b : \u2115), Coprime 0 (b + 1)\n\ncase hd\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a b : \u2115), a < b \u2192 Coprime (a + 1) b \u2192 Coprime a (b + 1) \u2192 Coprime (a + 1) (b + 1)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a < b", "rule": "have hab : a.Coprime b := by apply Nat.diag_induction"}], "hypo_name": [["hab"]]}
{"Nat.set_induction_bounded": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hk\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?k \u2208 Eq (gcd a b)\n\ncase h_ind\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 k \u2208 Eq (gcd a b), k + 1 \u2208 Eq (gcd a b)\n\ncase hnk\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?k \u2264 1\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.set_induction_bounded"}], "hypo_name": [["hab"]]}
{"Nat.set_induction": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 \u2208 Eq (gcd a b)\n\ncase h_ind\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 k \u2208 Eq (gcd a b), k + 1 \u2208 Eq (gcd a b)", "rule": "have hab : a.Coprime b := by apply Nat.set_induction"}], "hypo_name": [["hab"]]}
{"Nat.findGreatest_of_ne_zero": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 findGreatest (Coprime a) ?n = b\n\ncase h0\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2260 0\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.findGreatest_of_ne_zero"}], "hypo_name": [["hab"]]}
{"Set.coe_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Lean.Internal.coeM ?\u03b3\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2191(Eq (gcd a b))", "rule": "have hab : a.Coprime b := by apply Set.coe_subset"}], "hypo_name": [["hab"]]}
{"Set.image_val_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Subtype.val '' ?\u03b3\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2191(Eq (gcd a b))", "rule": "have hab : a.Coprime b := by apply Set.image_val_subset"}], "hypo_name": [["hab"]]}
{"Nat.Coprime.symmetric": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime b a", "rule": "have hab : a.Coprime b := by apply Nat.Coprime.symmetric"}], "hypo_name": [["hab"]]}
{"Nat.eq_one_of_dvd_coprimes": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h_ab_coprime\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime ?a ?b\n\ncase hka\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 ?a\n\ncase hkb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Nat.eq_one_of_dvd_coprimes"}], "hypo_name": [["hab"]]}
{"Set.fst_image_sigma_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Sigma.fst '' Set.sigma (Eq (gcd a b)) ?t\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Type ?u.7153394\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : \u2115) \u2192 Set (?\u03b1 i)", "rule": "have hab : a.Coprime b := by apply Set.fst_image_sigma_subset"}], "hypo_name": [["hab"]]}
{"Set.mapsTo_preimage": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 @OfNat.ofNat \u2115 1 \u207b\u00b9' Eq (gcd a b)", "rule": "have hab : a.Coprime b := by apply Set.mapsTo_preimage"}], "hypo_name": [["hab"]]}
{"Set.Subsingleton.image2": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton ?s\n\ncase ht\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton ?t\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.image2 ?f ?s ?t\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.image2 ?f ?s ?t\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7156309\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7156310\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.Subsingleton.image2"}], "hypo_name": [["hab"]]}
{"Set.eq_of_mem_uIcc_of_mem_uIcc": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.uIcc 1 ?c\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.uIcc (gcd a b) ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.eq_of_mem_uIcc_of_mem_uIcc"}], "hypo_name": [["hab"]]}
{"Set.eq_of_mem_uIcc_of_mem_uIcc'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.uIcc ?a 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.uIcc ?a (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.eq_of_mem_uIcc_of_mem_uIcc'"}], "hypo_name": [["hab"]]}
{"Set.uIcc_injective_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun b => Set.uIcc b ?a) (gcd a b) = (fun b => Set.uIcc b ?a) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.uIcc_injective_right"}], "hypo_name": [["hab"]]}
{"Set.uIcc_injective_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.uIcc ?a (gcd a b) = Set.uIcc ?a 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.uIcc_injective_left"}], "hypo_name": [["hab"]]}
{"Set.eq_of_mem_uIoc_of_mem_uIoc": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 \u0399 1 ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u0399 (gcd a b) ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.eq_of_mem_uIoc_of_mem_uIoc"}], "hypo_name": [["hab"]]}
{"Set.eq_of_mem_uIoc_of_mem_uIoc'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 \u0399 ?a 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u0399 ?a (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.eq_of_mem_uIoc_of_mem_uIoc'"}], "hypo_name": [["hab"]]}
{"Set.eq_of_not_mem_uIoc_of_not_mem_uIoc": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 ?c\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2209 \u0399 1 ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2209 \u0399 (gcd a b) ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.eq_of_not_mem_uIoc_of_not_mem_uIoc"}], "hypo_name": [["hab"]]}
{"Set.uIoc_injective_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun b => \u0399 b ?a) (gcd a b) = (fun b => \u0399 b ?a) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.uIoc_injective_right"}], "hypo_name": [["hab"]]}
{"Set.uIoc_injective_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u0399 ?a (gcd a b) = \u0399 ?a 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.uIoc_injective_left"}], "hypo_name": [["hab"]]}
{"Set.OrdConnected.out": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.OrdConnected (Eq (gcd a b))\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2208 Eq (gcd a b)\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?y \u2208 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.Icc ?x ?y\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase y\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.OrdConnected.out"}], "hypo_name": [["hab"]]}
{"Set.OrdConnected.uIcc_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.OrdConnected (Eq (gcd a b))\n\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2208 Eq (gcd a b)\n\ncase hy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?y \u2208 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.uIcc ?x ?y\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase y\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.OrdConnected.uIcc_subset"}], "hypo_name": [["hab"]]}
{"Set.OrdConnected.uIoc_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.OrdConnected (Eq (gcd a b))\n\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2208 Eq (gcd a b)\n\ncase hy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?y \u2208 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u0399 ?x ?y\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase y\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.OrdConnected.uIoc_subset"}], "hypo_name": [["hab"]]}
{"Set.fst_image_prod_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Prod.fst '' Eq (gcd a b) \u00d7\u02e2 ?t\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7171321\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.fst_image_prod_subset"}], "hypo_name": [["hab"]]}
{"Set.snd_image_prod_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Prod.snd '' ?s \u00d7\u02e2 Eq (gcd a b)\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7171396\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1", "rule": "have hab : a.Coprime b := by apply Set.snd_image_prod_subset"}], "hypo_name": [["hab"]]}
{"injective_toPullbackDiag": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 toPullbackDiag ?f (gcd a b) = toPullbackDiag ?f 1\n\ncase Y\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7172115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?Y", "rule": "have hab : a.Coprime b := by apply injective_toPullbackDiag"}], "hypo_name": [["hab"]]}
{"List.Pairwise.forall_of_forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Symmetric Coprime\n\ncase H\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?l, Coprime x x\n\ncase H\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Pairwise Coprime ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Pairwise.forall_of_forall"}], "hypo_name": [["hab"]]}
{"List.Pairwise.forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hR\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Symmetric Coprime\n\ncase hl\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Pairwise Coprime ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Pairwise.forall"}], "hypo_name": [["hab"]]}
{"List.Pairwise.set_pairwise": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hl\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Pairwise Coprime ?l\n\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Symmetric Coprime\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 {x | x \u2208 ?l}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 {x | x \u2208 ?l}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Pairwise.set_pairwise"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?t \u2286 ?s\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s Coprime\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.mono"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.mono'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?r \u2264 Coprime\n\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s ?r\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.mono'"}], "hypo_name": [["hab"]]}
{"Set.Subsingleton.pairwise": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Subsingleton.pairwise"}], "hypo_name": [["hab"]]}
{"Set.pairwise_empty": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 \u2205\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 \u2205\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b", "rule": "have hab : a.Coprime b := by apply Set.pairwise_empty"}], "hypo_name": [["hab"]]}
{"Set.pairwise_singleton": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 {?a}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 {?a}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.pairwise_singleton"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.insert": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 b \u2208 ?s, ?a \u2260 b \u2192 Coprime ?a b \u2227 Coprime b ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.insert"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.insert_of_not_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2209 ?s\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 b \u2208 ?s, Coprime ?a b \u2227 Coprime b ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.insert_of_not_mem"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.insert_of_symmetric": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s Coprime\n\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Symmetric Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 b \u2208 ?s, ?a \u2260 b \u2192 Coprime ?a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.insert_of_symmetric"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.insert_of_symmetric_of_not_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s Coprime\n\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Symmetric Coprime\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2209 ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 b \u2208 ?s, Coprime ?a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.insert_of_symmetric_of_not_mem"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.image": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s (Coprime on ?f)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?f '' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?f '' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7188169\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b9", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.image"}], "hypo_name": [["hab"]]}
{"Set.PairwiseDisjoint.elim_set": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.PairwiseDisjoint ?s ?f\n\ncase hi\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase hj\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase hai\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2208 ?f (gcd a b)\n\ncase haj\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2208 ?f 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7190595\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Set ?\u03b1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1", "rule": "have hab : a.Coprime b := by apply Set.PairwiseDisjoint.elim_set"}], "hypo_name": [["hab"]]}
{"List.rel_of_sorted_cons": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Sorted Coprime (a :: ?l)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.rel_of_sorted_cons"}], "hypo_name": [["hab"]]}
{"List.Sorted.rel_of_mem_take_of_mem_drop": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Sorted Coprime ?l\n\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 List.take ?k ?l\n\ncase hy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 List.drop ?k ?l\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115\n\ncase k\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply List.Sorted.rel_of_mem_take_of_mem_drop"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_Icc_of_ge": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2264 ?a\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.Icc ?a ?b\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.Icc ?a ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_Icc_of_ge"}], "hypo_name": [["hab"]]}
{"Set.Ici_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Ici (gcd a b) = Set.Ici 1", "rule": "have hab : a.Coprime b := by apply Set.Ici_injective"}], "hypo_name": [["hab"]]}
{"Set.Iic_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Iic (gcd a b) = Set.Iic 1", "rule": "have hab : a.Coprime b := by apply Set.Iic_injective"}], "hypo_name": [["hab"]]}
{"Set.Ioi_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Ioi (gcd a b) = Set.Ioi 1", "rule": "have hab : a.Coprime b := by apply Set.Ioi_injective"}], "hypo_name": [["hab"]]}
{"Set.Iio_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Iio (gcd a b) = Set.Iio 1", "rule": "have hab : a.Coprime b := by apply Set.Iio_injective"}], "hypo_name": [["hab"]]}
{"Eq.subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s = Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Eq.subset"}], "hypo_name": [["hab"]]}
{"Set.mem_of_mem_of_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 Eq (gcd a b)\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_of_mem_of_subset"}], "hypo_name": [["hab"]]}
{"Membership.mem.out": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 {x | Coprime a x}", "rule": "have hab : a.Coprime b := by apply Membership.mem.out"}], "hypo_name": [["hab"]]}
{"Set.Subset.refl": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Eq (gcd a b)", "rule": "have hab : a.Coprime b := by apply Set.Subset.refl"}], "hypo_name": [["hab"]]}
{"Set.Subset.rfl": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Eq (gcd a b)", "rule": "have hab : a.Coprime b := by apply Set.Subset.rfl"}], "hypo_name": [["hab"]]}
{"Set.Subset.trans": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2286 ?b\n\ncase bc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Subset.trans"}], "hypo_name": [["hab"]]}
{"Set.mem_of_eq_of_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 = ?y\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?y \u2208 Eq (gcd a b)\n\ncase y\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_of_eq_of_mem"}], "hypo_name": [["hab"]]}
{"Set.mem_of_subset_of_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s\u2081 \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\u2081\n\ncase s\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_of_subset_of_mem"}], "hypo_name": [["hab"]]}
{"Set.empty_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u2205", "rule": "have hab : a.Coprime b := by apply Set.empty_subset"}], "hypo_name": [["hab"]]}
{"Set.MemUnion.elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2208 ?a \u222a ?b\n\ncase H\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2208 ?a \u2192 Coprime a b\n\ncase H\u2083\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2208 ?b \u2192 Coprime a b\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7230365\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1", "rule": "have hab : a.Coprime b := by apply Set.MemUnion.elim"}], "hypo_name": [["hab"]]}
{"Set.union_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase sr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 Eq (gcd a b)\n\ncase tr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?t \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s \u222a ?t\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.union_subset"}], "hypo_name": [["hab"]]}
{"Set.mem_of_mem_inter_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Eq (gcd a b) \u2229 ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_of_mem_inter_left"}], "hypo_name": [["hab"]]}
{"Set.mem_of_mem_inter_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?a \u2229 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_of_mem_inter_right"}], "hypo_name": [["hab"]]}
{"Set.inter_subset_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Eq (gcd a b) \u2229 ?t\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.inter_subset_left"}], "hypo_name": [["hab"]]}
{"Set.inter_subset_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s \u2229 Eq (gcd a b)\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.inter_subset_right"}], "hypo_name": [["hab"]]}
{"Set.mem_of_mem_insert_of_ne": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 insert ?a (Eq (gcd a b))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2260 ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_of_mem_insert_of_ne"}], "hypo_name": [["hab"]]}
{"Set.eq_of_not_mem_of_mem_insert": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 insert 1 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2209 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.eq_of_not_mem_of_mem_insert"}], "hypo_name": [["hab"]]}
{"Set.insert_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2208 Eq (gcd a b)\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.insert_subset"}], "hypo_name": [["hab"]]}
{"Set.forall_of_forall_insert": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 insert ?a ?s, Coprime a x\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.forall_of_forall_insert"}], "hypo_name": [["hab"]]}
{"Set.forall_insert_of_forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Coprime a x\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?a\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 insert ?a ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.forall_insert_of_forall"}], "hypo_name": [["hab"]]}
{"Set.eq_of_mem_singleton": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 {1}", "rule": "have hab : a.Coprime b := by apply Set.eq_of_mem_singleton"}], "hypo_name": [["hab"]]}
{"Set.singleton_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 {gcd a b} = {1}", "rule": "have hab : a.Coprime b := by apply Set.singleton_injective"}], "hypo_name": [["hab"]]}
{"Set.mem_singleton_of_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b = 1", "rule": "have hab : a.Coprime b := by apply Set.mem_singleton_of_eq"}], "hypo_name": [["hab"]]}
{"Set.sep_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 {x | x \u2208 Eq (gcd a b) \u2227 ?p x}\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Set.sep_subset"}], "hypo_name": [["hab"]]}
{"Set.mem_of_mem_diff": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Eq (gcd a b) \\ ?t\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_of_mem_diff"}], "hypo_name": [["hab"]]}
{"Set.diff_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Eq (gcd a b) \\ ?t\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.diff_subset"}], "hypo_name": [["hab"]]}
{"Set.mem_powerset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?x\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_powerset"}], "hypo_name": [["hab"]]}
{"Set.subset_of_mem_powerset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x \u2208 \ud835\udcab Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?x\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.subset_of_mem_powerset"}], "hypo_name": [["hab"]]}
{"Set.monotone_powerset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2208 \ud835\udcab ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.monotone_powerset"}], "hypo_name": [["hab"]]}
{"Set.Subsingleton.anti": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ht\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton ?t\n\ncase hst\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 ?t\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Subsingleton.anti"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_empty": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 \u2205\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u2205", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_empty"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_singleton": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 {?a}\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 {?a}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_singleton"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_of_subset_singleton": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 {?a}\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_of_subset_singleton"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_of_forall_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 b \u2208 ?s, b = ?a\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_of_forall_eq"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_isTop": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 {x | IsTop x}\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 {x | IsTop x}", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_isTop"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_isBot": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 {x | IsBot x}\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 {x | IsBot x}", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_isBot"}], "hypo_name": [["hab"]]}
{"Set.monotone_setOf": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b : \u2115), Monotone fun a => a = b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 gcd a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 (fun a => {b | a = b}) ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.monotone_setOf"}], "hypo_name": [["hab"]]}
{"Set.antitone_setOf": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b : \u2115), Antitone fun a => a = b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 (fun a => {b | a = b}) ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.antitone_setOf"}], "hypo_name": [["hab"]]}
{"Set.antitone_bforall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?b, Coprime a x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.antitone_bforall"}], "hypo_name": [["hab"]]}
{"Disjoint.subset_left_of_subset_union": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 Eq (gcd a b) \u222a ?u\n\ncase hac\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint ?s ?u\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase u\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Disjoint.subset_left_of_subset_union"}], "hypo_name": [["hab"]]}
{"Disjoint.subset_right_of_subset_union": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 ?t \u222a Eq (gcd a b)\n\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint ?s ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Disjoint.subset_right_of_subset_union"}], "hypo_name": [["hab"]]}
{"List.Chain'.rel_head": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Chain' Coprime (a :: b :: ?l)\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Chain'.rel_head"}], "hypo_name": [["hab"]]}
{"List.Chain'.rel_head?": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Chain' Coprime (a :: ?l)\n\ncase hy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 List.head? ?l\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Chain'.rel_head?"}], "hypo_name": [["hab"]]}
{"List.Chain.induction": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Chain ?r ?a ?l\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.getLast (?a :: ?l) (_ : ?a :: ?l \u2260 []) = ?b\n\ncase carries\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 \u2983x y : \u2115\u2984, ?r x y \u2192 Coprime a y \u2192 Coprime a x\n\ncase final\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?a :: ?l\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Chain.induction"}], "hypo_name": [["hab"]]}
{"List.Chain.induction_head": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Chain ?r b ?l\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.getLast (b :: ?l) (_ : b :: ?l \u2260 []) = ?b\n\ncase carries\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 \u2983x y : \u2115\u2984, ?r x y \u2192 Coprime a y \u2192 Coprime a x\n\ncase final\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.Chain.induction_head"}], "hypo_name": [["hab"]]}
{"List.forall\u2082_zip": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Forall\u2082 Coprime ?l\u2081 ?l\u2082\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (a, b) \u2208 List.zip ?l\u2081 ?l\u2082\n\ncase l\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115\n\ncase l\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.forall\u2082_zip"}], "hypo_name": [["hab"]]}
{"Set.eqOn_empty": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 \u2205", "rule": "have hab : a.Coprime b := by apply Set.eqOn_empty"}], "hypo_name": [["hab"]]}
{"Set.EqOn.symm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn (fun {b} => 1) (gcd a) ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.EqOn.symm"}], "hypo_name": [["hab"]]}
{"Set.EqOn.trans": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn (gcd a) ?f\u2082 ?s\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn ?f\u2082 (fun {b} => 1) ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.EqOn.trans"}], "hypo_name": [["hab"]]}
{"Set.EqOn.mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s\u2081 \u2286 ?s\u2082\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn (gcd a) (fun {b} => 1) ?s\u2082\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\u2081\n\ncase s\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase s\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.EqOn.mono"}], "hypo_name": [["hab"]]}
{"Set.EqOn.union": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn (gcd a) (fun {b} => 1) ?s\u2081\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn (gcd a) (fun {b} => 1) ?s\u2082\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\u2081 \u222a ?s\u2082\n\ncase s\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase s\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.EqOn.union"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.subset_preimage": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?s (Eq (gcd a b))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.subset_preimage"}], "hypo_name": [["hab"]]}
{"Set.mapsTo_empty": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 \u2205", "rule": "have hab : a.Coprime b := by apply Set.mapsTo_empty"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.image_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo ?f ?s (Eq (gcd a b))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' ?s\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7302863\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.image_subset"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.congr": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo ?f\u2081 ?s (Eq (gcd a b))\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn ?f\u2081 (@OfNat.ofNat \u2115 1) ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase f\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 OfNat \u2115 1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.congr"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.comp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?t (Eq (gcd a b))\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo OfNat.mk ?s ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.comp"}], "hypo_name": [["hab"]]}
{"Set.mapsTo_id": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Eq (gcd a b)", "rule": "have hab : a.Coprime b := by apply Set.mapsTo_id"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?s\u2081 ?t\u2081\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s\u2082 \u2286 ?s\u2081\n\ncase ht\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?t\u2081 \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\u2082\n\ncase s\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase s\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase t\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.mono"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.mono_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?s\u2081 (Eq (gcd a b))\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s\u2082 \u2286 ?s\u2081\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\u2082\n\ncase s\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase s\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.mono_left"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.mono_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?s ?t\u2081\n\ncase ht\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?t\u2081 \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase t\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.mono_right"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.union": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?s\u2081 (Eq (gcd a b))\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?s\u2082 (Eq (gcd a b))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\u2081 \u222a ?s\u2082\n\ncase s\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase s\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.union"}], "hypo_name": [["hab"]]}
{"Set.MapsTo.comp_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hg\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (@OfNat.ofNat \u2115 1) ?s (Eq (gcd a b))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 OfNat.mk \u207b\u00b9' ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)", "rule": "have hab : a.Coprime b := by apply Set.MapsTo.comp_right"}], "hypo_name": [["hab"]]}
{"Set.Subsingleton.injOn": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304017\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.Subsingleton.injOn"}], "hypo_name": [["hab"]]}
{"Set.injOn_empty": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 \u2205\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u2205\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304050\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.injOn_empty"}], "hypo_name": [["hab"]]}
{"Set.injOn_singleton": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 {?a}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 {?a}\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304079\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.injOn_singleton"}], "hypo_name": [["hab"]]}
{"Set.InjOn.congr": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f\u2081 ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn ?f\u2081 ?f\u2082 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f\u2082 (gcd a b) = ?f\u2082 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304206\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase f\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.InjOn.congr"}], "hypo_name": [["hab"]]}
{"Set.InjOn.mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s\u2081 \u2286 ?s\u2082\n\ncase ht\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f ?s\u2082\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\u2081\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\u2081\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304271\n\ncase s\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase s\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.InjOn.mono"}], "hypo_name": [["hab"]]}
{"Set.injOn_of_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304380\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.injOn_of_injective"}], "hypo_name": [["hab"]]}
{"Set.injOn_id": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 id (gcd a b) = id 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.injOn_id"}], "hypo_name": [["hab"]]}
{"Set.InjOn.comp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hg\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?g ?t\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo ?f ?s ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (?g \u2218 ?f) (gcd a b) = (?g \u2218 ?f) 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304473\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304474\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 ?\u03b3", "rule": "have hab : a.Coprime b := by apply Set.InjOn.comp"}], "hypo_name": [["hab"]]}
{"Set.InjOn.image_of_comp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn (?g \u2218 ?f) ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?f '' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?g (gcd a b) = ?g 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304517\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304519\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b3", "rule": "have hab : a.Coprime b := by apply Set.InjOn.image_of_comp"}], "hypo_name": [["hab"]]}
{"Set.InjOn.iterate": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f ?s\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo ?f ?s ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f^[?n] (gcd a b) = ?f^[?n] 1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.InjOn.iterate"}], "hypo_name": [["hab"]]}
{"Function.Injective.injOn_range": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective (?g \u2218 ?f)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.range ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.range ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?g (gcd a b) = ?g 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304622\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304624\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b3", "rule": "have hab : a.Coprime b := by apply Function.Injective.injOn_range"}], "hypo_name": [["hab"]]}
{"Set.InjOn.mem_of_mem_image": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f ?s\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2286 ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f 1 \u2208 ?f '' Eq (gcd a b)\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304772\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.InjOn.mem_of_mem_image"}], "hypo_name": [["hab"]]}
{"Set.EqOn.cancel_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn (?g \u2218 gcd a) (?g \u2218 fun {b} => 1) ?s\n\ncase hg\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?g ?t\n\ncase hf\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (gcd a) ?s ?t\n\ncase hf\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (fun {b} => 1) ?s ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7304873\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b3", "rule": "have hab : a.Coprime b := by apply Set.EqOn.cancel_left"}], "hypo_name": [["hab"]]}
{"Set.EqOn.cancel_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.EqOn (gcd a \u2218 ?f) ((fun {b} => 1) \u2218 ?f) ?s\n\ncase hf'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.SurjOn ?f ?s ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?t\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7306147\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.EqOn.cancel_right"}], "hypo_name": [["hab"]]}
{"Set.BijOn.mapsTo": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.BijOn (@OfNat.ofNat \u2115 1) ?s (Eq (gcd a b))\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)", "rule": "have hab : a.Coprime b := by apply Set.BijOn.mapsTo"}], "hypo_name": [["hab"]]}
{"Set.BijOn.injOn": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.BijOn ?f ?s ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7306286\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.BijOn.injOn"}], "hypo_name": [["hab"]]}
{"Set.LeftInvOn.injOn": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.LeftInvOn ?f\u2081' ?f ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7307135\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase f\u2081'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.LeftInvOn.injOn"}], "hypo_name": [["hab"]]}
{"Set.LeftInvOn.mapsTo": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.LeftInvOn (@OfNat.ofNat \u2115 1) ?f (Eq (gcd a b))\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.SurjOn ?f (Eq (gcd a b)) ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?t\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 OfNat \u2115 1", "rule": "have hab : a.Coprime b := by apply Set.LeftInvOn.mapsTo"}], "hypo_name": [["hab"]]}
{"Set.RightInvOn.mapsTo": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.RightInvOn ?f' (@OfNat.ofNat \u2115 1) (Eq (gcd a b))\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.SurjOn ?f' (Eq (gcd a b)) ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (OfNat \u2115 1)\n\ncase f'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 OfNat \u2115 1", "rule": "have hab : a.Coprime b := by apply Set.RightInvOn.mapsTo"}], "hypo_name": [["hab"]]}
{"Set.eqOn_of_leftInvOn_of_rightInvOn": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.LeftInvOn (gcd a) ?f ?s\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.RightInvOn (fun {b} => 1) ?f ?t\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.MapsTo (fun {b} => 1) ?t ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?t\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.eqOn_of_leftInvOn_of_rightInvOn"}], "hypo_name": [["hab"]]}
{"Function.invFunOn_image_image_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Function.invFunOn ?f (Eq (gcd a b)) '' (?f '' Eq (gcd a b))\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7308684\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.invFunOn_image_image_subset"}], "hypo_name": [["hab"]]}
{"Function.Injective.comp_injOn": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hg\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?g\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (?g \u2218 ?f) (gcd a b) = (?g \u2218 ?f) 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7313323\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7313324\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 ?\u03b3\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Function.Injective.comp_injOn"}], "hypo_name": [["hab"]]}
{"Function.Semiconj.injOn_image": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Semiconj ?f ?fa ?fb\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?fa ?s\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f (?fa '' ?s)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?f '' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?fb (gcd a b) = ?fb 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7313657\n\ncase fa\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b1\n\ncase fb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1", "rule": "have hab : a.Coprime b := by apply Function.Semiconj.injOn_image"}], "hypo_name": [["hab"]]}
{"Function.Semiconj.injOn_range": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Semiconj ?f ?fa ?fb\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?fa\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f (Set.range ?fa)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.range ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.range ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?fb (gcd a b) = ?fb 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7313700\n\ncase fa\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b1\n\ncase fb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Function.Semiconj.injOn_range"}], "hypo_name": [["hab"]]}
{"Function.Semiconj.injOn_preimage": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Semiconj ?f ?fa ?fb\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?fb ?s\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.InjOn ?f (?f \u207b\u00b9' ?s)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?f \u207b\u00b9' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f \u207b\u00b9' ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?fa (gcd a b) = ?fa 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7313860\n\ncase fa\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115\n\ncase fb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 ?\u03b2\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.Semiconj.injOn_preimage"}], "hypo_name": [["hab"]]}
{"Function.insert_injOn": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\u1d9c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\u1d9c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun a => insert a ?s) (gcd a b) = (fun a => insert a ?s) 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Function.insert_injOn"}], "hypo_name": [["hab"]]}
{"Set.mem_iInter_of_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9), 1 \u2208 ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => ?s i\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7320561\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_iInter_of_mem"}], "hypo_name": [["hab"]]}
{"Set.mem_iInter\u2082_of_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9) (j : ?\u03ba i), 1 \u2208 ?s i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, ?s i j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7320588\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7320589\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_iInter\u2082_of_mem"}], "hypo_name": [["hab"]]}
{"Set.kernImage_mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2208 Set.kernImage ?f ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f 1 = ?a\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7320671\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.kernImage_mono"}], "hypo_name": [["hab"]]}
{"Set.compl_range_subset_kernImage": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2208 (Set.range ?f)\u1d9c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f 1 = ?a\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7320800\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.compl_range_subset_kernImage"}], "hypo_name": [["hab"]]}
{"Set.iUnion_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9), ?s i \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c3 i, ?s i\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321304\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iUnion_subset"}], "hypo_name": [["hab"]]}
{"Set.iUnion\u2082_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9) (j : ?\u03ba i), ?s i j \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c3 i, \u22c3 j, ?s i j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321331\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7321332\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iUnion\u2082_subset"}], "hypo_name": [["hab"]]}
{"Set.subset_iInter": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9), ?t \u2286 ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => ?s i\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321366\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.subset_iInter"}], "hypo_name": [["hab"]]}
{"Set.subset_iInter\u2082": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9) (j : ?\u03ba i), ?s \u2286 ?t i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, ?t i j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321397\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7321398\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.subset_iInter\u2082"}], "hypo_name": [["hab"]]}
{"Set.iInter_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, Eq i", "rule": "have hab : a.Coprime b := by apply Set.iInter_subset"}], "hypo_name": [["hab"]]}
{"Set.iInter_subset_of_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s ?i \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, ?s i\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321692\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115\n\ncase i\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9", "rule": "have hab : a.Coprime b := by apply Set.iInter_subset_of_subset"}], "hypo_name": [["hab"]]}
{"Set.iInter\u2082_subset_of_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s ?i ?j \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, \u22c2 j, ?s i j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321761\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7321762\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115\n\ncase i\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9\n\ncase j\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03ba ?i", "rule": "have hab : a.Coprime b := by apply Set.iInter\u2082_subset_of_subset"}], "hypo_name": [["hab"]]}
{"Set.iInter_mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9), ?s i \u2286 ?t i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => ?t i\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321902\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iInter_mono"}], "hypo_name": [["hab"]]}
{"Set.iInter_mono''": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9), ?s i \u2286 ?t i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.iInter ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range ?t\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321935\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iInter_mono''"}], "hypo_name": [["hab"]]}
{"Set.iInter\u2082_mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9) (j : ?\u03ba i), ?s i j \u2286 ?t i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, \u22c2 j, ?s i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, ?t i j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7321968\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7321969\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iInter\u2082_mono"}], "hypo_name": [["hab"]]}
{"Set.iInter_mono'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (j : ?\u03b9'), \u2203 i, ?s i \u2286 ?t j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun j => ?t j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7322093\n\ncase \u03b9'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7322094\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9' \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iInter_mono'"}], "hypo_name": [["hab"]]}
{"Set.iInter\u2082_mono'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i' : ?\u03b9') (j' : ?\u03ba' i'), \u2203 i j, ?s i j \u2286 ?t i' j'\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, \u22c2 j, ?s i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i' => \u22c2 j', ?t i' j'\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7322128\n\ncase \u03b9'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7322129\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7322130\n\ncase \u03ba'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9' \u2192 Sort ?u.7322131\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i' : ?\u03b9') \u2192 ?\u03ba' i' \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iInter\u2082_mono'"}], "hypo_name": [["hab"]]}
{"Set.iInter_subset_iInter\u2082": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 i, ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 x, ?s i\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7322205\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7322206\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iInter_subset_iInter\u2082"}], "hypo_name": [["hab"]]}
{"Set.iUnion_iInter_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c3 j, \u22c2 i, ?s i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c3 j, ?s i j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7323353\n\ncase \u03b9'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7323354\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 ?\u03b9' \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.iUnion_iInter_subset"}], "hypo_name": [["hab"]]}
{"Set.mem_biInter": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, 1 \u2208 ?t x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun x => \u22c2 (_ : x \u2208 ?s), ?t x\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7324580\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mem_biInter"}], "hypo_name": [["hab"]]}
{"Set.biInter_subset_of_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase xs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 x \u2208 ?s, Eq x\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.biInter_subset_of_mem"}], "hypo_name": [["hab"]]}
{"Set.biInter_subset_biInter_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s' \u2286 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 x \u2208 ?s, ?t x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun x => \u22c2 (_ : x \u2208 ?s'), ?t x\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7324706\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase s'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.biInter_subset_biInter_left"}], "hypo_name": [["hab"]]}
{"Set.biInter_mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 ?s'\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, ?t x \u2286 ?t' x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2 x \u2208 ?s', ?t x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun x => \u22c2 (_ : x \u2208 ?s), ?t' x\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7324780\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase s'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 Set \u2115\n\ncase t'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.biInter_mono"}], "hypo_name": [["hab"]]}
{"Set.sInter_subset_of_mem": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase tS\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 ?S\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2\u2080 ?S\n\ncase S\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (Set \u2115)", "rule": "have hab : a.Coprime b := by apply Set.sInter_subset_of_mem"}], "hypo_name": [["hab"]]}
{"Set.sUnion_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 t' \u2208 ?S, t' \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c3\u2080 ?S\n\ncase S\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (Set \u2115)", "rule": "have hab : a.Coprime b := by apply Set.sUnion_subset"}], "hypo_name": [["hab"]]}
{"Set.subset_sInter": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 t' \u2208 ?S, ?t \u2286 t'\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 ?S\n\ncase S\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (Set \u2115)\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.subset_sInter"}], "hypo_name": [["hab"]]}
{"Set.sInter_subset_sInter": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?S \u2286 ?T\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c2\u2080 ?T\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 ?S\n\ncase S\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (Set \u2115)\n\ncase T\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (Set \u2115)", "rule": "have hab : a.Coprime b := by apply Set.sInter_subset_sInter"}], "hypo_name": [["hab"]]}
{"Set.mapsTo_iInter_iInter": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9), Set.MapsTo (@OfNat.ofNat \u2115 1) (?s i) (?t i)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 \u22c2 i, ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => ?t i\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7327602\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set (OfNat \u2115 1)\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mapsTo_iInter_iInter"}], "hypo_name": [["hab"]]}
{"Set.mapsTo_iInter\u2082_iInter\u2082": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9) (j : ?\u03ba i), Set.MapsTo (@OfNat.ofNat \u2115 1) (?s i j) (?t i j)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 \u22c2 i, \u22c2 j, ?s i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, ?t i j\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7327641\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7327642\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set (OfNat \u2115 1)\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.mapsTo_iInter\u2082_iInter\u2082"}], "hypo_name": [["hab"]]}
{"Set.image_iInter_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' \u22c2 i, ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => ?f '' ?s i\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7327688\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7327690\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set ?\u03b1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.image_iInter_subset"}], "hypo_name": [["hab"]]}
{"Set.image_iInter\u2082_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' \u22c2 i, \u22c2 j, ?s i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, ?f '' ?s i j\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7327719\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7327721\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7327722\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set ?\u03b1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.image_iInter\u2082_subset"}], "hypo_name": [["hab"]]}
{"Set.image_sInter_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' \u22c2\u2080 ?S\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun s => \u22c2 (_ : s \u2208 ?S), ?f '' s\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7327756\n\ncase S\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set (Set ?\u03b1)\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.image_sInter_subset"}], "hypo_name": [["hab"]]}
{"Set.inj_on_iUnion_of_directed": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Directed (fun x x_1 => x \u2286 x_1) ?s\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (i : ?\u03b9), Set.InjOn ?f (?s i)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 \u22c3 i, ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u22c3 i, ?s i\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7328017\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7328018\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.inj_on_iUnion_of_directed"}], "hypo_name": [["hab"]]}
{"Set.monotone_preimage": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 @OfNat.ofNat \u2115 1 \u207b\u00b9' ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.monotone_preimage"}], "hypo_name": [["hab"]]}
{"Set.image2_iInter_subset_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.image2 ?f (\u22c2 i, ?s i) ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => Set.image2 ?f (?s i) ?t\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329773\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329774\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7329776\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.image2_iInter_subset_left"}], "hypo_name": [["hab"]]}
{"Set.image2_iInter_subset_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.image2 ?f ?s (\u22c2 i, ?t i)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => Set.image2 ?f ?s (?t i)\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329810\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329811\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7329813\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Set ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.image2_iInter_subset_right"}], "hypo_name": [["hab"]]}
{"Set.image2_iInter\u2082_subset_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.image2 ?f (\u22c2 i, \u22c2 j, ?s i j) ?t\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, Set.image2 ?f (?s i j) ?t\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329847\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329848\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7329850\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7329851\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.image2_iInter\u2082_subset_left"}], "hypo_name": [["hab"]]}
{"Set.image2_iInter\u2082_subset_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Set.image2 ?f ?s (\u22c2 i, \u22c2 j, ?t i j)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, Set.image2 ?f ?s (?t i j)\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329890\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7329891\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7329893\n\ncase \u03ba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b9 \u2192 Sort ?u.7329894\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.image2_iInter\u2082_subset_right"}], "hypo_name": [["hab"]]}
{"Set.preimage_mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s \u2286 Eq (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 @OfNat.ofNat \u2115 1 \u207b\u00b9' ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.preimage_mono"}], "hypo_name": [["hab"]]}
{"Set.ball_image_of_ball": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Coprime a (?f x)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?f '' ?s\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7332062\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1", "rule": "have hab : a.Coprime b := by apply Set.ball_image_of_ball"}], "hypo_name": [["hab"]]}
{"Set.mem_image_elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Coprime a (?f x)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?f '' ?s\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7332115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1", "rule": "have hab : a.Coprime b := by apply Set.mem_image_elim"}], "hypo_name": [["hab"]]}
{"Set.mem_image_elim_on": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h_y\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?f '' ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Coprime a (?f x)\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7332144\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1", "rule": "have hab : a.Coprime b := by apply Set.mem_image_elim_on"}], "hypo_name": [["hab"]]}
{"Set.image_subset_preimage_of_inverse": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase I\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.LeftInverse (@OfNat.ofNat \u2115 1) ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 instOfNatNat 1 \u2208 ?f '' Eq (gcd a b)\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 OfNat \u2115 1", "rule": "have hab : a.Coprime b := by apply Set.image_subset_preimage_of_inverse"}], "hypo_name": [["hab"]]}
{"Set.image_preimage_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' (?f \u207b\u00b9' Eq (gcd a b))\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7333421\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.image_preimage_subset"}], "hypo_name": [["hab"]]}
{"Set.range_const_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.range fun x => 1\n\ncase \u03b9\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7335479", "rule": "have hab : a.Coprime b := by apply Set.range_const_subset"}], "hypo_name": [["hab"]]}
{"Set.Subsingleton.image": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?f '' ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f '' ?s\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7336211\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Set.Subsingleton.image"}], "hypo_name": [["hab"]]}
{"Set.Subsingleton.preimage": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton ?s\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?f\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?f \u207b\u00b9' ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?f \u207b\u00b9' ?s\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7336243\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set ?\u03b2\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Set.Subsingleton.preimage"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_of_image": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?f\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton (?f '' ?s)\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7336276\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_of_image"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_of_preimage": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Surjective ?f\n\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Subsingleton (?f \u207b\u00b9' ?s)\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7336308\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_of_preimage"}], "hypo_name": [["hab"]]}
{"Subtype.coe_image_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Subtype.val '' ?t\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2191(Eq (gcd a b))", "rule": "have hab : a.Coprime b := by apply Subtype.coe_image_subset"}], "hypo_name": [["hab"]]}
{"List.forall_mem_of_forall_mem_union_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?l\u2081 \u222a ?l\u2082, Coprime a x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\u2081\n\ncase l\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115\n\ncase l\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.forall_mem_of_forall_mem_union_left"}], "hypo_name": [["hab"]]}
{"List.forall_mem_of_forall_mem_union_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?l\u2081 \u222a ?l\u2082, Coprime a x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\u2082\n\ncase l\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115\n\ncase l\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.forall_mem_of_forall_mem_union_right"}], "hypo_name": [["hab"]]}
{"List.forall_mem_inter_of_forall_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?l\u2081, Coprime a x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\u2081 \u2229 ?l\u2082\n\ncase l\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115\n\ncase l\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.forall_mem_inter_of_forall_left"}], "hypo_name": [["hab"]]}
{"List.forall_mem_inter_of_forall_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?l\u2082, Coprime a x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\u2081 \u2229 ?l\u2082\n\ncase l\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115\n\ncase l\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.forall_mem_inter_of_forall_right"}], "hypo_name": [["hab"]]}
{"List.inj_on_of_nodup_map": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase d\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Nodup (List.map ?f ?l)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7341859\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.inj_on_of_nodup_map"}], "hypo_name": [["hab"]]}
{"List.all_one_of_le_one_le_of_prod_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hl\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?l, 1 \u2264 x\n\ncase hl\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.prod ?l = 1\n\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?l\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.all_one_of_le_one_le_of_prod_eq_one"}], "hypo_name": [["hab"]]}
{"Nat.succPNat_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 succPNat (gcd a b) = succPNat 1", "rule": "have hab : a.Coprime b := by apply Nat.succPNat_injective"}], "hypo_name": [["hab"]]}
{"List.singleton_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun a => [a]) (gcd a b) = (fun a => [a]) 1", "rule": "have hab : a.Coprime b := by apply List.singleton_injective"}], "hypo_name": [["hab"]]}
{"List.forall_mem_of_forall_mem_cons": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?a :: ?l, Coprime a x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?l\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List \u2115", "rule": "have hab : a.Coprime b := by apply List.forall_mem_of_forall_mem_cons"}], "hypo_name": [["hab"]]}
{"List.replicate_right_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hn\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?n \u2260 0\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.replicate ?n (gcd a b) = List.replicate ?n 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply List.replicate_right_injective"}], "hypo_name": [["hab"]]}
{"List.replicate_left_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => List.replicate x ?a) (gcd a b) = (fun x => List.replicate x ?a) 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7365342\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1", "rule": "have hab : a.Coprime b := by apply List.replicate_left_injective"}], "hypo_name": [["hab"]]}
{"List.get?_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2080\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b < List.length ?xs\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.Nodup ?xs\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.get? ?xs (gcd a b) = List.get? ?xs 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7369577\n\ncase xs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List ?\u03b1", "rule": "have hab : a.Coprime b := by apply List.get?_injective"}], "hypo_name": [["hab"]]}
{"List.eq_of_mem_map_const": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 List.map (Function.const ?\u03b1 1) ?l\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7375743\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List ?\u03b1", "rule": "have hab : a.Coprime b := by apply List.eq_of_mem_map_const"}], "hypo_name": [["hab"]]}
{"List.injective_foldl_comp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hl\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 f \u2208 ?l, Function.Injective f\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List.foldl Function.comp ?f ?l (gcd a b) = List.foldl Function.comp ?f ?l 1\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 List (\u2115 \u2192 \u2115)\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply List.injective_foldl_comp"}], "hypo_name": [["hab"]]}
{"Option.Mem.leftUnique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Option \u2115", "rule": "have hab : a.Coprime b := by apply Option.Mem.leftUnique"}], "hypo_name": [["hab"]]}
{"Option.some_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 some (gcd a b) = some 1", "rule": "have hab : a.Coprime b := by apply Option.some_injective"}], "hypo_name": [["hab"]]}
{"fin_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Fin (gcd a b) = Fin 1", "rule": "have hab : a.Coprime b := by apply fin_injective"}], "hypo_name": [["hab"]]}
{"Sym.replicate_right_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?n \u2260 0\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sym.replicate ?n (gcd a b) = Sym.replicate ?n 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Sym.replicate_right_injective"}], "hypo_name": [["hab"]]}
{"Sum.inl_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sum.inl (gcd a b) = Sum.inl 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7471993", "rule": "have hab : a.Coprime b := by apply Sum.inl_injective"}], "hypo_name": [["hab"]]}
{"Sum.inr_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sum.inr (gcd a b) = Sum.inr 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7472016", "rule": "have hab : a.Coprime b := by apply Sum.inr_injective"}], "hypo_name": [["hab"]]}
{"Finset.filter_card_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (Finset.filter (Coprime a) ?s).card = ?s.card\n\ncase hx\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115", "rule": "have hab : a.Coprime b := by apply Finset.filter_card_eq"}], "hypo_name": [["hab"]]}
{"Finset.inj_on_of_surj_on_of_card_le": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a : \u2115) (ha : a \u2208 ?s), ?f a ha \u2208 ?t\n\ncase hsurj\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 b \u2208 ?t, \u2203 a, \u2203 (ha : a \u2208 ?s), ?f a ha = b\n\ncase hst\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s.card \u2264 ?t.card\n\ncase ha\u2081a\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) ?ha\u2081 = ?f 1 ?ha\u2082\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7496614\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115\n\ncase t\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset ?\u03b2\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (a : \u2115) \u2192 a \u2208 ?s \u2192 ?\u03b2\n\ncase ha\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase ha\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s", "rule": "have hab : a.Coprime b := by apply Finset.inj_on_of_surj_on_of_card_le"}], "hypo_name": [["hab"]]}
{"Finset.property_of_mem_map_subtype": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 Finset.map (Function.Embedding.subtype fun x => Coprime a x) ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset { x // Coprime a x }", "rule": "have hab : a.Coprime b := by apply Finset.property_of_mem_map_subtype"}], "hypo_name": [["hab"]]}
{"Finset.map_subtype_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u2191(Finset.map (Function.Embedding.subtype fun x => x \u2208 Eq (gcd a b)) ?s)\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2191(Eq (gcd a b))", "rule": "have hab : a.Coprime b := by apply Finset.map_subtype_subset"}], "hypo_name": [["hab"]]}
{"Finset.eq_of_mem_uIcc_of_mem_uIcc": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Finset.uIcc 1 ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Finset.uIcc (gcd a b) ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Finset.eq_of_mem_uIcc_of_mem_uIcc"}], "hypo_name": [["hab"]]}
{"Finset.eq_of_mem_uIcc_of_mem_uIcc'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Finset.uIcc ?a 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 Finset.uIcc ?a (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Finset.eq_of_mem_uIcc_of_mem_uIcc'"}], "hypo_name": [["hab"]]}
{"Finset.uIcc_injective_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun b => Finset.uIcc b ?a) (gcd a b) = (fun b => Finset.uIcc b ?a) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Finset.uIcc_injective_right"}], "hypo_name": [["hab"]]}
{"Finset.uIcc_injective_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset.uIcc ?a (gcd a b) = Finset.uIcc ?a 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Finset.uIcc_injective_left"}], "hypo_name": [["hab"]]}
{"Finset.eq_of_mem_singleton": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 {1}", "rule": "have hab : a.Coprime b := by apply Finset.eq_of_mem_singleton"}], "hypo_name": [["hab"]]}
{"Finset.singleton_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 {gcd a b} = {1}", "rule": "have hab : a.Coprime b := by apply Finset.singleton_injective"}], "hypo_name": [["hab"]]}
{"Finset.forall_of_forall_cons": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 Finset.cons ?a ?s ?h, Coprime a x\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2209 ?s", "rule": "have hab : a.Coprime b := by apply Finset.forall_of_forall_cons"}], "hypo_name": [["hab"]]}
{"Finset.eq_of_not_mem_of_mem_insert": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 insert 1 ?s\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2209 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115", "rule": "have hab : a.Coprime b := by apply Finset.eq_of_not_mem_of_mem_insert"}], "hypo_name": [["hab"]]}
{"Finset.insert_inj_on": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 (\u2191?s)\u1d9c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 (\u2191?s)\u1d9c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun a => insert a ?s) (gcd a b) = (fun a => insert a ?s) 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115", "rule": "have hab : a.Coprime b := by apply Finset.insert_inj_on"}], "hypo_name": [["hab"]]}
{"Finset.eq_of_mem_of_not_mem_erase": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase hsa\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2209 Finset.erase ?s 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115", "rule": "have hab : a.Coprime b := by apply Finset.eq_of_mem_of_not_mem_erase"}], "hypo_name": [["hab"]]}
{"Finset.erase_injOn": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 \u2191?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 \u2191?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset.erase ?s (gcd a b) = Finset.erase ?s 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115", "rule": "have hab : a.Coprime b := by apply Finset.erase_injOn"}], "hypo_name": [["hab"]]}
{"Finset.forall_of_forall_insert": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 insert ?a ?s, Coprime a x\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115", "rule": "have hab : a.Coprime b := by apply Finset.forall_of_forall_insert"}], "hypo_name": [["hab"]]}
{"sigma_mk_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 { fst := { fst := a, snd := b },\n      snd :=\n        Acc.rec\n          (fun x\u2081 h ih =>\n            (fun _x a =>\n                PSigma.casesOn (motive := fun x =>\n                  ((y : (_ : \u2115) \u00d7' \u2115) \u2192\n                      (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1 y x \u2192 \u2115) \u2192\n                    \u2115)\n                  _x\n                  (fun m n a =>\n                    if h : m = 0 then n\n                    else\n                      a { fst := n % m, snd := m }\n                        (_ :\n                          (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1\n                            { fst := n % m, snd := m } { fst := m, snd := n }))\n                  a)\n              x\u2081 ih)\n          (_ :\n            Acc (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1\n              { fst := a, snd := b }) } =\n    { fst := { fst := a, snd := b }, snd := 1 }", "rule": "have hab : a.Coprime b := by apply sigma_mk_injective"}], "hypo_name": [["hab"]]}
{"Function.Injective.of_sigma_map": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective (Sigma.map ?f\u2081 ?f\u2082)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f\u2082 { fst := a, snd := b }\n      (Acc.rec\n        (fun x\u2081 h ih =>\n          (fun _x a =>\n              PSigma.casesOn (motive := fun x =>\n                ((y : (_ : \u2115) \u00d7' \u2115) \u2192\n                    (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1 y x \u2192 \u2115) \u2192\n                  \u2115)\n                _x\n                (fun m n a =>\n                  if h : m = 0 then n\n                  else\n                    a { fst := n % m, snd := m }\n                      (_ :\n                        (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1\n                          { fst := n % m, snd := m } { fst := m, snd := n }))\n                a)\n            x\u2081 ih)\n        (_ :\n          Acc (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1 { fst := a, snd := b })) =\n    ?f\u2082 { fst := a, snd := b } 1\n\ncase \u03b1\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7556442\n\ncase \u03b2\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1\u2082 \u2192 Type ?u.7556444\n\ncase f\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (_ : \u2115) \u00d7' \u2115 \u2192 ?\u03b1\u2082\n\ncase f\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (a : (_ : \u2115) \u00d7' \u2115) \u2192 \u2115 \u2192 ?\u03b2\u2082 (?f\u2081 a)", "rule": "have hab : a.Coprime b := by apply Function.Injective.of_sigma_map"}], "hypo_name": [["hab"]]}
{"Int.pow_right_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 < Int.natAbs ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a ^ x) (gcd a b) = (fun x => ?a ^ x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2124", "rule": "have hab : a.Coprime b := by apply Int.pow_right_injective"}], "hypo_name": [["hab"]]}
{"Prod.mk.inj_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (?a, gcd a b) = (?a, 1)\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7566974\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1", "rule": "have hab : a.Coprime b := by apply Prod.mk.inj_left"}], "hypo_name": [["hab"]]}
{"Prod.mk.inj_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun a => (a, ?b)) (gcd a b) = (fun a => (a, ?b)) 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7566999\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Prod.mk.inj_right"}], "hypo_name": [["hab"]]}
{"Mathlib.Tactic.Contrapose.mtr": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acCoprime a b \u2192 \u00ac?p\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?p\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Mathlib.Tactic.Contrapose.mtr"}], "hypo_name": [["hab"]]}
{"Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Subsingleton ?\u03b1 \u2192 Coprime a b\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Nontrivial ?\u03b1 \u2192 Coprime a b\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7769981", "rule": "have hab : a.Coprime b := by apply Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim"}], "hypo_name": [["hab"]]}
{"Mathlib.Meta.NormNum.IsNat.to_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Mathlib.Meta.NormNum.IsNat (gcd a b) ?n\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2191?n = 1\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.IsNat.to_eq"}], "hypo_name": [["hab"]]}
{"Mathlib.Meta.NormNum.IsNat.to_raw_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Mathlib.Meta.NormNum.IsNat (gcd a b) 1", "rule": "have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.IsNat.to_raw_eq"}], "hypo_name": [["hab"]]}
{"Mathlib.Meta.NormNum.isNat.natElim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Mathlib.Meta.NormNum.IsNat b ?n'\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?n'\n\ncase n'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.isNat.natElim"}], "hypo_name": [["hab"]]}
{"Mathlib.Meta.NormNum.isNat_eq_true": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Mathlib.Meta.NormNum.IsNat (gcd a b) ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Mathlib.Meta.NormNum.IsNat 1 ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.isNat_eq_true"}], "hypo_name": [["hab"]]}
{"Mathlib.Tactic.Ring.cast_pos": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Mathlib.Meta.NormNum.IsNat (gcd a b) 1", "rule": "have hab : a.Coprime b := by apply Mathlib.Tactic.Ring.cast_pos"}], "hypo_name": [["hab"]]}
{"Mathlib.Tactic.Ring.of_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b = ?c\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 = ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Mathlib.Tactic.Ring.of_eq"}], "hypo_name": [["hab"]]}
{"Relator.RightTotal.rel_forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relator.RightTotal ?R\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (?R \u21d2 fun x x_1 => x \u2192 x_1) ?a (Coprime a)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (i : ?\u03b1) \u2192 ?a i\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7791561\n\ncase R\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115 \u2192 Prop\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 Sort ?u.7791562", "rule": "have hab : a.Coprime b := by apply Relator.RightTotal.rel_forall"}], "hypo_name": [["hab"]]}
{"Relator.left_unique_of_rel_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase he\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (?R \u21d2 ?R \u21d2 Iff) Eq ?eq'\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?R (gcd a b) ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?R 1 ?c\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7791687\n\ncase R\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2 \u2192 Prop\n\ncase eq'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 ?\u03b2 \u2192 Prop\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Relator.left_unique_of_rel_eq"}], "hypo_name": [["hab"]]}
{"Relator.LeftUnique.flip": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relator.LeftUnique ?r\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 flip ?r ?a (gcd a b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 flip ?r ?a 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7791776\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2 \u2192 Prop\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Relator.LeftUnique.flip"}], "hypo_name": [["hab"]]}
{"Reflexive.rel_of_ne_imp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Reflexive Coprime\n\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b \u2192 Coprime a b", "rule": "have hab : a.Coprime b := by apply Reflexive.rel_of_ne_imp"}], "hypo_name": [["hab"]]}
{"Relation.reflGen_minimal": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hr'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Reflexive Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x y : \u2115), ?r x y \u2192 Coprime x y\n\ncase hxy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relation.ReflGen ?r a b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Relation.reflGen_minimal"}], "hypo_name": [["hab"]]}
{"Relation.transGen_minimal": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hr'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Transitive Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x y : \u2115), ?r x y \u2192 Coprime x y\n\ncase hxy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relation.TransGen ?r a b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Relation.transGen_minimal"}], "hypo_name": [["hab"]]}
{"Relation.reflTransGen_minimal": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hr\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Reflexive Coprime\n\ncase hr\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Transitive Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x y : \u2115), ?r x y \u2192 Coprime x y\n\ncase hxy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relation.ReflTransGen ?r a b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Relation.reflTransGen_minimal"}], "hypo_name": [["hab"]]}
{"Relation.join_of_equivalence": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Equivalence Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a b : \u2115), ?r' a b \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relation.Join ?r' a b\n\ncase r'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Relation.join_of_equivalence"}], "hypo_name": [["hab"]]}
{"Relation.reflTransGen_of_transitive_reflexive": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Reflexive Coprime\n\ncase ht\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Transitive Coprime\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a b : \u2115), ?r' a b \u2192 Coprime a b\n\ncase h'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relation.ReflTransGen ?r' a b\n\ncase r'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Relation.reflTransGen_of_transitive_reflexive"}], "hypo_name": [["hab"]]}
{"Relation.reflTransGen_of_equivalence": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Equivalence Coprime\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a b : \u2115), ?r' a b \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Relation.ReflTransGen ?r' a b\n\ncase r'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Relation.reflTransGen_of_equivalence"}], "hypo_name": [["hab"]]}
{"Function.Embedding.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7797078\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u21aa ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.Embedding.injective"}], "hypo_name": [["hab"]]}
{"Function.Injective.iterate": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase Hinj\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f^[?n] (gcd a b) = ?f^[?n] 1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115\n\ncase n\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Function.Injective.iterate"}], "hypo_name": [["hab"]]}
{"Pairwise.mono": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hr\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Pairwise ?r\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 \u2983i j : \u2115\u2984, ?r i j \u2192 Coprime i j\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Pairwise.mono"}], "hypo_name": [["hab"]]}
{"Pairwise.eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Pairwise ?r\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?r (gcd a b) 1\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Pairwise.eq"}], "hypo_name": [["hab"]]}
{"Set.pairwise_of_forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a b : \u2115), Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.pairwise_of_forall"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.imp_on": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s ?r\n\ncase hrp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s fun \u2983a b\u2984 => ?r a b \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.imp_on"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.imp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s ?r\n\ncase hpq\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 \u2983a b : \u2115\u2984, ?r a b \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.imp"}], "hypo_name": [["hab"]]}
{"Set.Pairwise.eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set.Pairwise ?s ?r\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?r (gcd a b) 1\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Set.Pairwise.eq"}], "hypo_name": [["hab"]]}
{"Pairwise.set_pairwise": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Pairwise Coprime\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2260 b\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply Pairwise.set_pairwise"}], "hypo_name": [["hab"]]}
{"congr_heq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 HEq (gcd a) (@OfNat.ofNat \u2115 1)\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 HEq b (instOfNatNat 1)", "rule": "have hab : a.Coprime b := by apply congr_heq"}], "hypo_name": [["hab"]]}
{"Fact.elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Fact (Coprime a b)", "rule": "have hab : a.Coprime b := by apply Fact.elim"}], "hypo_name": [["hab"]]}
{"by_contradiction": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acCoprime a b \u2192 False", "rule": "have hab : a.Coprime b := by apply by_contradiction"}], "hypo_name": [["hab"]]}
{"by_cases": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hpq\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?p \u2192 Coprime a b\n\ncase hnpq\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?p \u2192 Coprime a b\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply by_cases"}], "hypo_name": [["hab"]]}
{"of_not_not": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac\u00acCoprime a b", "rule": "have hab : a.Coprime b := by apply of_not_not"}], "hypo_name": [["hab"]]}
{"of_not_imp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac(Coprime a b \u2192 ?b)\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply of_not_imp"}], "hypo_name": [["hab"]]}
{"Not.imp_symm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acCoprime a b \u2192 ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Not.imp_symm"}], "hypo_name": [["hab"]]}
{"Or.elim3": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2228 ?b \u2228 ?c\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2192 Coprime a b\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2192 Coprime a b\n\ncase hc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?c \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Or.elim3"}], "hypo_name": [["hab"]]}
{"Function.mtr": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acCoprime a b \u2192 \u00ac?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Function.mtr"}], "hypo_name": [["hab"]]}
{"peirce": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (Coprime a b \u2192 ?b) \u2192 Coprime a b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply peirce"}], "hypo_name": [["hab"]]}
{"Exists.fst": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Exists ?p\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a b \u2192 Prop", "rule": "have hab : a.Coprime b := by apply Exists.fst"}], "hypo_name": [["hab"]]}
{"BEx.elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2203 x, \u2203 (h : ?p x), ?P x h\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a_1 : ?\u03b1) (h : ?p a_1), ?P a_1 h \u2192 Coprime a b\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7807067\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 Prop\n\ncase P\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (x : ?\u03b1) \u2192 ?p x \u2192 Prop", "rule": "have hab : a.Coprime b := by apply BEx.elim"}], "hypo_name": [["hab"]]}
{"BAll.imp_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?p x \u2192 ?q x\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?q x \u2192 Coprime a x\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?p b\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Prop\n\ncase q\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply BAll.imp_left"}], "hypo_name": [["hab"]]}
{"ball_of_forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), Coprime a x", "rule": "have hab : a.Coprime b := by apply ball_of_forall"}], "hypo_name": [["hab"]]}
{"forall_of_ball": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?p x\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), ?p x \u2192 Coprime a x\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply forall_of_ball"}], "hypo_name": [["hab"]]}
{"Equiv.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?e (gcd a b) = ?e 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7817452\n\ncase e\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2243 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Equiv.injective"}], "hypo_name": [["hab"]]}
{"Ordering.Compares.le_antisymm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Ordering.Compares ?o (gcd a b) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b\n\ncase o\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Ordering", "rule": "have hab : a.Coprime b := by apply Ordering.Compares.le_antisymm"}], "hypo_name": [["hab"]]}
{"Equiv.Perm.eq_of_prodExtendRight_ne": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (Equiv.Perm.prodExtendRight 1 ?e) (gcd a b, ?b) \u2260 (gcd a b, ?b)\n\ncase \u03b2\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7844970\n\ncase e\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Equiv.Perm ?\u03b2\u2081\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2\u2081", "rule": "have hab : a.Coprime b := by apply Equiv.Perm.eq_of_prodExtendRight_ne"}], "hypo_name": [["hab"]]}
{"Acc.induction_bot'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Acc ?r ?a\n\ncase ih\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b_1 : OfNat \u2115 1), 1 \u2260 1 \u2192 gcd a b = 1 \u2192 \u2203 c, ?r c b_1 \u2227 gcd a b = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b = 1\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 OfNat \u2115 1 \u2192 OfNat \u2115 1 \u2192 Prop\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 OfNat \u2115 1", "rule": "have hab : a.Coprime b := by apply Acc.induction_bot'"}], "hypo_name": [["hab"]]}
{"Acc.induction_bot": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Acc ?r ?a\n\ncase ih\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b_1 : \u2115), b_1 \u2260 b \u2192 Coprime a b_1 \u2192 \u2203 c, ?r c b_1 \u2227 Coprime a c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?a\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Acc.induction_bot"}], "hypo_name": [["hab"]]}
{"WellFounded.induction_bot'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hwf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 WellFounded ?r\n\ncase ih\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b_1 : OfNat \u2115 1), 1 \u2260 1 \u2192 gcd a b = 1 \u2192 \u2203 c, ?r c b_1 \u2227 gcd a b = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b = 1\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 OfNat \u2115 1 \u2192 OfNat \u2115 1 \u2192 Prop\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 OfNat \u2115 1", "rule": "have hab : a.Coprime b := by apply WellFounded.induction_bot'"}], "hypo_name": [["hab"]]}
{"WellFounded.induction_bot": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hwf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 WellFounded ?r\n\ncase ih\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b_1 : \u2115), b_1 \u2260 b \u2192 Coprime a b_1 \u2192 \u2203 c, ?r c b_1 \u2227 Coprime a c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?a\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply WellFounded.induction_bot"}], "hypo_name": [["hab"]]}
{"IsMin.eq_of_le": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsMin 1\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1", "rule": "have hab : a.Coprime b := by apply IsMin.eq_of_le"}], "hypo_name": [["hab"]]}
{"IsMin.eq_of_ge": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsMin (gcd a b)\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b", "rule": "have hab : a.Coprime b := by apply IsMin.eq_of_ge"}], "hypo_name": [["hab"]]}
{"IsMax.eq_of_le": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsMax (gcd a b)\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1", "rule": "have hab : a.Coprime b := by apply IsMax.eq_of_le"}], "hypo_name": [["hab"]]}
{"IsMax.eq_of_ge": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsMax 1\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b", "rule": "have hab : a.Coprime b := by apply IsMax.eq_of_ge"}], "hypo_name": [["hab"]]}
{"Function.Bijective.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Bijective ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7863273\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.Bijective.injective"}], "hypo_name": [["hab"]]}
{"Function.Injective.of_comp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase I\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective (?f \u2218 ?g)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?g (gcd a b) = ?g 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7863591\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7863592\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 ?\u03b2\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b1", "rule": "have hab : a.Coprime b := by apply Function.Injective.of_comp"}], "hypo_name": [["hab"]]}
{"Function.Injective.of_comp_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase I\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective (?f \u2218 ?g)\n\ncase hg\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Surjective ?g\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7863653\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7863654\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b3 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Function.Injective.of_comp_right"}], "hypo_name": [["hab"]]}
{"Function.injective_of_isPartialInv": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.IsPartialInv ?f ?g\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7864722\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 Option \u2115", "rule": "have hab : a.Coprime b := by apply Function.injective_of_isPartialInv"}], "hypo_name": [["hab"]]}
{"Function.injective_of_isPartialInv_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.IsPartialInv ?f ?g\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2208 ?g (gcd a b)\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2208 ?g 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7864751\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Option ?\u03b1\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1", "rule": "have hab : a.Coprime b := by apply Function.injective_of_isPartialInv_right"}], "hypo_name": [["hab"]]}
{"Function.RightInverse.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.RightInverse ?f ?g\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7865061\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Function.RightInverse.injective"}], "hypo_name": [["hab"]]}
{"Function.injective_surjInv": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.surjInv ?h (gcd a b) = Function.surjInv ?h 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7865871\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Surjective ?f", "rule": "have hab : a.Coprime b := by apply Function.injective_surjInv"}], "hypo_name": [["hab"]]}
{"Function.update_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.update ?f { fst := a, snd := b }\n      (Acc.rec\n        (fun x\u2081 h ih =>\n          (fun _x a =>\n              PSigma.casesOn (motive := fun x =>\n                ((y : (_ : \u2115) \u00d7' \u2115) \u2192\n                    (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1 y x \u2192 \u2115) \u2192\n                  \u2115)\n                _x\n                (fun m n a =>\n                  if h : m = 0 then n\n                  else\n                    a { fst := n % m, snd := m }\n                      (_ :\n                        (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1\n                          { fst := n % m, snd := m } { fst := m, snd := n }))\n                a)\n            x\u2081 ih)\n        (_ :\n          Acc (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1 { fst := a, snd := b })) =\n    Function.update ?f { fst := a, snd := b } 1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (_ : \u2115) \u00d7' \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Function.update_injective"}], "hypo_name": [["hab"]]}
{"Function.Involutive.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Involutive ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply Function.Involutive.injective"}], "hypo_name": [["hab"]]}
{"Function.Injective2.left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective2 ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun a => ?f a ?b) (gcd a b) = (fun a => ?f a ?b) 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7874718\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7874719\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2 \u2192 ?\u03b3\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.Injective2.left"}], "hypo_name": [["hab"]]}
{"Function.Injective2.right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective2 ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f ?a (gcd a b) = ?f ?a 1\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7874750\n\ncase \u03b3\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.7874752\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 \u2115 \u2192 ?\u03b3\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1", "rule": "have hab : a.Coprime b := by apply Function.Injective2.right"}], "hypo_name": [["hab"]]}
{"WCovBy.Ico_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2a7f ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.Ico 1 ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply WCovBy.Ico_subset"}], "hypo_name": [["hab"]]}
{"WCovBy.Ioc_subset": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2a7f 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 Set.Ioc ?a 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply WCovBy.Ioc_subset"}], "hypo_name": [["hab"]]}
{"CovBy.unique_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u22d6 ?c\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u22d6 ?c\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply CovBy.unique_left"}], "hypo_name": [["hab"]]}
{"CovBy.unique_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u22d6 gcd a b\n\ncase hc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u22d6 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply CovBy.unique_right"}], "hypo_name": [["hab"]]}
{"CovBy.eq_of_between": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u22d6 1\n\ncase hbc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u22d6 ?c\n\ncase hax\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a < gcd a b\n\ncase hxc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b < ?c\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply CovBy.eq_of_between"}], "hypo_name": [["hab"]]}
{"GaloisConnection.u_unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase gc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 GaloisConnection ?l (gcd a)\n\ncase gc'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 GaloisConnection ?l' fun {b} => 1\n\ncase hl\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (a : \u2115), ?l a = ?l' a\n\ncase l\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115\n\ncase l'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply GaloisConnection.u_unique"}], "hypo_name": [["hab"]]}
{"GaloisConnection.l_unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase gc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 GaloisConnection (gcd a) ?u\n\ncase gc'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 GaloisConnection (fun {b} => 1) ?u'\n\ncase hu\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b : \u2115), ?u b = ?u' b\n\ncase u\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115\n\ncase u'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115", "rule": "have hab : a.Coprime b := by apply GaloisConnection.l_unique"}], "hypo_name": [["hab"]]}
{"IsAntichain.eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsAntichain ?r ?s\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?r (gcd a b) 1\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply IsAntichain.eq"}], "hypo_name": [["hab"]]}
{"IsAntichain.eq'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsAntichain ?r ?s\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?r 1 (gcd a b)\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply IsAntichain.eq'"}], "hypo_name": [["hab"]]}
{"IsStrongAntichain.eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hs\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsStrongAntichain ?r ?s\n\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase hac\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?r (gcd a b) ?c\n\ncase hbc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?r 1 ?c\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase c\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsStrongAntichain.eq"}], "hypo_name": [["hab"]]}
{"WellFoundedLT.induction": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), (\u2200 y < x, Coprime a y) \u2192 Coprime a x", "rule": "have hab : a.Coprime b := by apply WellFoundedLT.induction"}], "hypo_name": [["hab"]]}
{"WithBot.coe_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2191(gcd a b) = \u21911", "rule": "have hab : a.Coprime b := by apply WithBot.coe_injective"}], "hypo_name": [["hab"]]}
{"WithTop.coe_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2191(gcd a b) = \u21911", "rule": "have hab : a.Coprime b := by apply WithTop.coe_injective"}], "hypo_name": [["hab"]]}
{"eq_of_inf_eq_sup_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2293 ?a = 1 \u2293 ?a\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2294 ?a = 1 \u2294 ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_of_inf_eq_sup_eq"}], "hypo_name": [["hab"]]}
{"Monotone.forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hP\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), Monotone (Coprime x)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), Coprime x ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Monotone.forall"}], "hypo_name": [["hab"]]}
{"Antitone.forall": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hP\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), Antitone (Coprime x)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2264 ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), Coprime x ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Antitone.forall"}], "hypo_name": [["hab"]]}
{"Monotone.ball": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hP\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Monotone (Coprime x)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Coprime x ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Monotone.ball"}], "hypo_name": [["hab"]]}
{"Antitone.ball": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hP\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Antitone (Coprime x)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2264 ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, Coprime x ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Antitone.ball"}], "hypo_name": [["hab"]]}
{"ge_antisymm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1", "rule": "have hab : a.Coprime b := by apply ge_antisymm"}], "hypo_name": [["hab"]]}
{"eq_of_le_of_not_lt": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1\n\ncase hba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00acgcd a b < 1", "rule": "have hab : a.Coprime b := by apply eq_of_le_of_not_lt"}], "hypo_name": [["hab"]]}
{"eq_of_ge_of_not_gt": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b\n\ncase hba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u00ac1 < gcd a b", "rule": "have hab : a.Coprime b := by apply eq_of_ge_of_not_gt"}], "hypo_name": [["hab"]]}
{"eq_of_forall_le_iff": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (c : \u2115), c \u2264 gcd a b \u2194 c \u2264 1", "rule": "have hab : a.Coprime b := by apply eq_of_forall_le_iff"}], "hypo_name": [["hab"]]}
{"eq_of_forall_ge_iff": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase H\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (c : \u2115), gcd a b \u2264 c \u2194 1 \u2264 c", "rule": "have hab : a.Coprime b := by apply eq_of_forall_ge_iff"}], "hypo_name": [["hab"]]}
{"eq_of_forall_lt_iff": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (c : \u2115), c < gcd a b \u2194 c < 1", "rule": "have hab : a.Coprime b := by apply eq_of_forall_lt_iff"}], "hypo_name": [["hab"]]}
{"eq_of_forall_gt_iff": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (c : \u2115), gcd a b < c \u2194 1 < c", "rule": "have hab : a.Coprime b := by apply eq_of_forall_gt_iff"}], "hypo_name": [["hab"]]}
{"injective_of_lt_imp_ne": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x y : \u2115), x < y \u2192 ?f x \u2260 ?f y\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7974232\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply injective_of_lt_imp_ne"}], "hypo_name": [["hab"]]}
{"RelEmbedding.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.7998701\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 ?\u03b2 \u2192 Prop\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?r \u21aar ?s", "rule": "have hab : a.Coprime b := by apply RelEmbedding.injective"}], "hypo_name": [["hab"]]}
{"RelIso.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?e (gcd a b) = ?e 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.8000197\n\ncase r\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 \u2115 \u2192 Prop\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 ?\u03b2 \u2192 Prop\n\ncase e\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?r \u2243r ?s", "rule": "have hab : a.Coprime b := by apply RelIso.injective"}], "hypo_name": [["hab"]]}
{"IsLeast.unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase Ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLeast ?s (gcd a b)\n\ncase Hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLeast ?s 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply IsLeast.unique"}], "hypo_name": [["hab"]]}
{"IsGreatest.unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase Ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsGreatest ?s (gcd a b)\n\ncase Hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsGreatest ?s 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply IsGreatest.unique"}], "hypo_name": [["hab"]]}
{"IsLUB.unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase Ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLUB ?s (gcd a b)\n\ncase Hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLUB ?s 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply IsLUB.unique"}], "hypo_name": [["hab"]]}
{"IsGLB.unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase Ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsGLB ?s (gcd a b)\n\ncase Hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsGLB ?s 1\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115", "rule": "have hab : a.Coprime b := by apply IsGLB.unique"}], "hypo_name": [["hab"]]}
{"Set.subsingleton_of_isLUB_le_isGLB": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase Ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsGLB ?s ?a\n\ncase Hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLUB ?s ?b\n\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2264 ?a\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Set \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Set.subsingleton_of_isLUB_le_isGLB"}], "hypo_name": [["hab"]]}
{"Contravariant.flip": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Contravariant ?M \u2115 ?\u03bc Eq\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 flip Eq (?\u03bc ?m 1) (?\u03bc ?m (gcd a b))\n\ncase M\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.8059025\n\ncase \u03bc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?M \u2192 \u2115 \u2192 \u2115\n\ncase m\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?M", "rule": "have hab : a.Coprime b := by apply Contravariant.flip"}], "hypo_name": [["hab"]]}
{"eq_of_prime_pow_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hp\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 _root_.Prime (gcd a b)\n\ncase hp\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 _root_.Prime 1\n\ncase hk\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 < ?k\u2081\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b ^ ?k\u2081 = 1 ^ ?k\u2082\n\ncase k\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase k\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_of_prime_pow_eq"}], "hypo_name": [["hab"]]}
{"eq_of_prime_pow_eq'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hp\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 _root_.Prime (gcd a b)\n\ncase hp\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 _root_.Prime 1\n\ncase hk\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 < ?k\u2082\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b ^ ?k\u2081 = 1 ^ ?k\u2082\n\ncase k\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase k\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_of_prime_pow_eq'"}], "hypo_name": [["hab"]]}
{"Associates.mk_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Associates.mk (gcd a b) = Associates.mk 1", "rule": "have hab : a.Coprime b := by apply Associates.mk_injective"}], "hypo_name": [["hab"]]}
{"eq_of_zero_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 0 = 1", "rule": "have hab : a.Coprime b := by apply eq_of_zero_eq_one"}], "hypo_name": [["hab"]]}
{"dvd_antisymm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2223 gcd a b", "rule": "have hab : a.Coprime b := by apply dvd_antisymm"}], "hypo_name": [["hab"]]}
{"dvd_antisymm'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2223 gcd a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2223 1", "rule": "have hab : a.Coprime b := by apply dvd_antisymm'"}], "hypo_name": [["hab"]]}
{"eq_of_forall_dvd": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (c : \u2115), gcd a b \u2223 c \u2194 1 \u2223 c", "rule": "have hab : a.Coprime b := by apply eq_of_forall_dvd"}], "hypo_name": [["hab"]]}
{"eq_of_forall_dvd'": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (c : \u2115), c \u2223 gcd a b \u2194 c \u2223 1", "rule": "have hab : a.Coprime b := by apply eq_of_forall_dvd'"}], "hypo_name": [["hab"]]}
{"MulOpposite.op_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 MulOpposite.op (gcd a b) = MulOpposite.op 1", "rule": "have hab : a.Coprime b := by apply MulOpposite.op_injective"}], "hypo_name": [["hab"]]}
{"MulLECancellable.isLeftRegular": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 MulLECancellable ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a * x) (gcd a b) = (fun x => ?a * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply MulLECancellable.isLeftRegular"}], "hypo_name": [["hab"]]}
{"IsLeftRegular.right_of_commute": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ca\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b : \u2115), Commute ?a b\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLeftRegular ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x * ?a) (gcd a b) = (fun x => x * ?a) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsLeftRegular.right_of_commute"}], "hypo_name": [["hab"]]}
{"IsRightRegular.left_of_commute": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ca\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (b : \u2115), Commute ?a b\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsRightRegular ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a * x) (gcd a b) = (fun x => ?a * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsRightRegular.left_of_commute"}], "hypo_name": [["hab"]]}
{"IsLeftRegular.mul": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase lra\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLeftRegular ?a\n\ncase lrb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLeftRegular ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a * ?b * x) (gcd a b) = (fun x => ?a * ?b * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsLeftRegular.mul"}], "hypo_name": [["hab"]]}
{"IsRightRegular.mul": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase rra\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsRightRegular ?a\n\ncase rrb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsRightRegular ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x * (?a * ?b)) (gcd a b) = (fun x => x * (?a * ?b)) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsRightRegular.mul"}], "hypo_name": [["hab"]]}
{"IsLeftRegular.of_mul": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsLeftRegular (?a * ?b)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?b * x) (gcd a b) = (fun x => ?b * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsLeftRegular.of_mul"}], "hypo_name": [["hab"]]}
{"IsRightRegular.of_mul": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsRightRegular (?b * ?a)\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x * ?b) (gcd a b) = (fun x => x * ?b) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsRightRegular.of_mul"}], "hypo_name": [["hab"]]}
{"isLeftRegular_of_mul_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b * ?a = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a * x) (gcd a b) = (fun x => ?a * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply isLeftRegular_of_mul_eq_one"}], "hypo_name": [["hab"]]}
{"isRightRegular_of_mul_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a * ?b = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x * ?a) (gcd a b) = (fun x => x * ?a) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply isRightRegular_of_mul_eq_one"}], "hypo_name": [["hab"]]}
{"mul_left_cancel\u2080": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2260 0\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a * gcd a b = ?a * 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply mul_left_cancel\u2080"}], "hypo_name": [["hab"]]}
{"mul_right_injective\u2080": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2260 0\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a * x) (gcd a b) = (fun x => ?a * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply mul_right_injective\u2080"}], "hypo_name": [["hab"]]}
{"mul_right_cancel\u2080": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2260 0\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b * ?b = 1 * ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply mul_right_cancel\u2080"}], "hypo_name": [["hab"]]}
{"mul_left_injective\u2080": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2260 0\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun a => a * ?b) (gcd a b) = (fun a => a * ?b) 1\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply mul_left_injective\u2080"}], "hypo_name": [["hab"]]}
{"tsub_inj_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 gcd a b\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b - ?a = 1 - ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply tsub_inj_left"}], "hypo_name": [["hab"]]}
{"AddLECancellable.tsub_inj_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 AddLECancellable (?a - gcd a b)\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 ?a\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 ?a\n\ncase h\u2083\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a - gcd a b = ?a - 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply AddLECancellable.tsub_inj_right"}], "hypo_name": [["hab"]]}
{"tsub_inj_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 ?a\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 ?a\n\ncase h\u2083\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a - gcd a b = ?a - 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply tsub_inj_right"}], "hypo_name": [["hab"]]}
{"eq_one_of_one_le_mul_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b \u2264 1\n\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b * ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_one_of_one_le_mul_left"}], "hypo_name": [["hab"]]}
{"eq_one_of_mul_le_one_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 ?b\n\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b * ?b \u2264 1\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_one_of_mul_le_one_left"}], "hypo_name": [["hab"]]}
{"eq_one_of_one_le_mul_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 1\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1\n\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 ?a * gcd a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_one_of_one_le_mul_right"}], "hypo_name": [["hab"]]}
{"eq_one_of_mul_le_one_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 ?a\n\ncase hb\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b\n\ncase hab\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a * gcd a b \u2264 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_one_of_mul_le_one_right"}], "hypo_name": [["hab"]]}
{"MulLECancellable.Injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 MulLECancellable ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a * x) (gcd a b) = (fun x => ?a * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply MulLECancellable.Injective"}], "hypo_name": [["hab"]]}
{"MulLECancellable.injective_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase ha\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 MulLECancellable ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x * ?a) (gcd a b) = (fun x => x * ?a) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply MulLECancellable.injective_left"}], "hypo_name": [["hab"]]}
{"eq_one_of_mul_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b * ?b = 1\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_one_of_mul_right"}], "hypo_name": [["hab"]]}
{"eq_one_of_mul_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a * gcd a b = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply eq_one_of_mul_left"}], "hypo_name": [["hab"]]}
{"IsUnit.mul_left_cancel": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsUnit ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a * gcd a b = ?a * 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsUnit.mul_left_cancel"}], "hypo_name": [["hab"]]}
{"IsUnit.mul_right_cancel": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsUnit ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b * ?b = 1 * ?b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsUnit.mul_right_cancel"}], "hypo_name": [["hab"]]}
{"IsUnit.mul_right_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsUnit ?a\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => ?a * x) (gcd a b) = (fun x => ?a * x) 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsUnit.mul_right_injective"}], "hypo_name": [["hab"]]}
{"IsUnit.mul_left_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 IsUnit ?b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (fun x => x * ?b) (gcd a b) = (fun x => x * ?b) 1\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply IsUnit.mul_left_injective"}], "hypo_name": [["hab"]]}
{"left_inv_eq_right_inv": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hba\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b * ?a = 1\n\ncase hac\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a * 1 = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply left_inv_eq_right_inv"}], "hypo_name": [["hab"]]}
{"Pi.mulSingle_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Pi.mulSingle { fst := a, snd := b }\n      (Acc.rec\n        (fun x\u2081 h ih =>\n          (fun _x a =>\n              PSigma.casesOn (motive := fun x =>\n                ((y : (_ : \u2115) \u00d7' \u2115) \u2192\n                    (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1 y x \u2192 \u2115) \u2192\n                  \u2115)\n                _x\n                (fun m n a =>\n                  if h : m = 0 then n\n                  else\n                    a { fst := n % m, snd := m }\n                      (_ :\n                        (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1\n                          { fst := n % m, snd := m } { fst := m, snd := n }))\n                a)\n            x\u2081 ih)\n        (_ :\n          Acc (invImage (fun a => PSigma.casesOn a fun m snd => m) instWellFoundedRelation).1 { fst := a, snd := b })) =\n    Pi.mulSingle { fst := a, snd := b } 1", "rule": "have hab : a.Coprime b := by apply Pi.mulSingle_injective"}], "hypo_name": [["hab"]]}
{"inv_unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hy\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x * gcd a b = 1\n\ncase hz\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?x * 1 = 1\n\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply inv_unique"}], "hypo_name": [["hab"]]}
{"Multiset.all_one_of_le_one_le_of_prod_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, 1 \u2264 x\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset.prod ?s = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Multiset \u2115", "rule": "have hab : a.Coprime b := by apply Multiset.all_one_of_le_one_le_of_prod_eq_one"}], "hypo_name": [["hab"]]}
{"Finset.eq_of_card_le_one_of_prod_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hc\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?s.card \u2264 1\n\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (Finset.prod ?s fun x => gcd a x) = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115", "rule": "have hab : a.Coprime b := by apply Finset.eq_of_card_le_one_of_prod_eq"}], "hypo_name": [["hab"]]}
{"Finset.eq_one_of_prod_eq_one": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hp\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (Finset.prod ?s fun x => gcd a x) = 1\n\ncase h1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 x \u2208 ?s, x \u2260 ?a \u2192 gcd a x = 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 b \u2208 ?s\n\ncase s\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Finset \u2115\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Finset.eq_one_of_prod_eq_one"}], "hypo_name": [["hab"]]}
{"Functor.Const.ext": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Functor.Const.run (gcd a b) = Functor.Const.run 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Type ?u.8351459", "rule": "have hab : a.Coprime b := by apply Functor.Const.ext"}], "hypo_name": [["hab"]]}
{"Nat.divisors_injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 divisors (gcd a b) = divisors 1", "rule": "have hab : a.Coprime b := by apply Nat.divisors_injective"}], "hypo_name": [["hab"]]}
{"Function.Injective.comp": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hg\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?g\n\ncase hf\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.Injective ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 (?g \u2218 ?f) (gcd a b) = (?g \u2218 ?f) 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.8416632\n\ncase \u03c6\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.8416631\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 ?\u03c6\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.Injective.comp"}], "hypo_name": [["hab"]]}
{"Function.LeftInverse.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.LeftInverse ?g ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.8416731\n\ncase g\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b2 \u2192 \u2115\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.LeftInverse.injective"}], "hypo_name": [["hab"]]}
{"Function.HasLeftInverse.injective": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Function.HasLeftInverse ?f\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?f (gcd a b) = ?f 1\n\ncase \u03b2\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.8416761\n\ncase f\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 ?\u03b2", "rule": "have hab : a.Coprime b := by apply Function.HasLeftInverse.injective"}], "hypo_name": [["hab"]]}
{"Function.injective_id": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 id (gcd a b) = id 1", "rule": "have hab : a.Coprime b := by apply Function.injective_id"}], "hypo_name": [["hab"]]}
{"Implies.trans": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?p \u2192 ?q\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?q \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?p\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop\n\ncase q\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Prop", "rule": "have hab : a.Coprime b := by apply Implies.trans"}], "hypo_name": [["hab"]]}
{"trans_rel_left": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?b\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?b = b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply trans_rel_left"}], "hypo_name": [["hab"]]}
{"trans_rel_right": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 a = ?b\n\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime ?b b\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply trans_rel_right"}], "hypo_name": [["hab"]]}
{"of_heq_true": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 HEq (Coprime a b) True", "rule": "have hab : a.Coprime b := by apply of_heq_true"}], "hypo_name": [["hab"]]}
{"ExistsUnique.elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2203! x, ?p x\n\ncase h\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : ?\u03b1), ?p x \u2192 (\u2200 (y : ?\u03b1), ?p y \u2192 y = x) \u2192 Coprime a b\n\ncase \u03b1\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Sort ?u.8420540\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?\u03b1 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply ExistsUnique.elim"}], "hypo_name": [["hab"]]}
{"ExistsUnique.unique": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2203! x, ?p x\n\ncase py\u2081\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?p (gcd a b)\n\ncase py\u2082\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?p 1\n\ncase p\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115 \u2192 Prop", "rule": "have hab : a.Coprime b := by apply ExistsUnique.unique"}], "hypo_name": [["hab"]]}
{"AsTrue.get": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase x\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 AsTrue (Coprime a b)", "rule": "have hab : a.Coprime b := by apply AsTrue.get"}], "hypo_name": [["hab"]]}
{"let_body_eq": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (x : \u2115), gcd a x = 1", "rule": "have hab : a.Coprime b := by apply let_body_eq"}], "hypo_name": [["hab"]]}
{"Equivalence.reflexive": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Equivalence fun {b} => Coprime a", "rule": "have hab : a.Coprime b := by apply Equivalence.reflexive"}], "hypo_name": [["hab"]]}
{"Equivalence.symmetric": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Equivalence Coprime\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime b a", "rule": "have hab : a.Coprime b := by apply Equivalence.symmetric"}], "hypo_name": [["hab"]]}
{"Equivalence.transitive": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Equivalence Coprime\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a ?y\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime ?y b\n\ncase y\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2115", "rule": "have hab : a.Coprime b := by apply Equivalence.transitive"}], "hypo_name": [["hab"]]}
{"Bool.of_decide_true": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 decide (Coprime a b) = true", "rule": "have hab : a.Coprime b := by apply Bool.of_decide_true"}], "hypo_name": [["hab"]]}
{"Nat.bit0_inj": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 bit0 (gcd a b) = bit0 1", "rule": "have hab : a.Coprime b := by apply Nat.bit0_inj"}], "hypo_name": [["hab"]]}
{"Nat.bit1_inj": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 bit1 (gcd a b) = bit1 1", "rule": "have hab : a.Coprime b := by apply Nat.bit1_inj"}], "hypo_name": [["hab"]]}
{"Nat.strong_induction_on": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), (\u2200 m < n, Coprime a m) \u2192 Coprime a n", "rule": "have hab : a.Coprime b := by apply Nat.strong_induction_on"}], "hypo_name": [["hab"]]}
{"Nat.case_strong_induction_on": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase hz\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Coprime a 0\n\ncase hi\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), (\u2200 m \u2264 n, Coprime a m) \u2192 Coprime a (succ n)", "rule": "have hab : a.Coprime b := by apply Nat.case_strong_induction_on"}], "hypo_name": [["hab"]]}
{"Int.le.elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a \u2264 ?b\n\ncase h'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), ?a + \u2191n = ?b \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2124\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2124", "rule": "have hab : a.Coprime b := by apply Int.le.elim"}], "hypo_name": [["hab"]]}
{"Int.lt.elim": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase h\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 ?a < ?b\n\ncase h'\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2200 (n : \u2115), ?a + \u2191(succ n) = ?b \u2192 Coprime a b\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2124\n\ncase b\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 \u2124", "rule": "have hab : a.Coprime b := by apply Int.lt.elim"}], "hypo_name": [["hab"]]}
{"le_antisymm": [{"init_state": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 Disjoint (Finset.filter IsPrimePow (divisors a)) (Finset.filter IsPrimePow (divisors b))", "next_state": "unsolved goals\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 gcd a b \u2264 1\n\ncase a\nR : Type u_1\ninst\u271d : CommMonoidWithZero R\nn p : R\nk a b : \u2115\nhab : Coprime a b\n\u22a2 1 \u2264 gcd a b", "rule": "have hab : a.Coprime b := by apply le_antisymm"}], "hypo_name": [["hab"]]}
