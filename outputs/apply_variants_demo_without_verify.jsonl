{"file_name": "Mathlib/Algebra/IsPrimePow.lean", "loc": {"Nat.disjoint_divisors_filter_isPrimePow": [[114, 119], [121, 126], [128, 133], [135, 140], [142, 147], [149, 154], [156, 161], [163, 168], [170, 175], [177, 182], [184, 189], [191, 196], [198, 203], [205, 210], [212, 217], [219, 224], [226, 231], [233, 238], [240, 245], [247, 252], [254, 259], [261, 266], [268, 273], [275, 280], [282, 287], [289, 294], [296, 301], [303, 308], [310, 315], [317, 322], [324, 329], [331, 336], [338, 343], [345, 350], [352, 357], [359, 364], [366, 371], [373, 378], [380, 385], [387, 392], [394, 399], [401, 406], [408, 413], [415, 420], [422, 427], [429, 434], [436, 441], [443, 448], [450, 455], [457, 462], [464, 469], [471, 476], [478, 483], [485, 490], [492, 497], [499, 504], [506, 511], [513, 518], [520, 525], [527, 532], [534, 539], [541, 546], [548, 553], [555, 560], [562, 567], [569, 574], [576, 581], [583, 588], [590, 595], [597, 602], [604, 609], [611, 616], [618, 623], [625, 630], [632, 637], [639, 644], [646, 651], [653, 658], [660, 665], [667, 672], [674, 679], [681, 686], [688, 693], [695, 700], [702, 707], [709, 714], [716, 721], [723, 728], [730, 735], [737, 742], [744, 749], [751, 756], [758, 763], [765, 770], [772, 777], [779, 784], [786, 791], [793, 798], [800, 805], [807, 812], [814, 819], [821, 826], [828, 833], [835, 840], [842, 847], [849, 854], [856, 861], [863, 868], [870, 875], [877, 882], [884, 889], [891, 896], [898, 903], [905, 910], [912, 917], [919, 924], [926, 931], [933, 938], [940, 945], [947, 952], [954, 959], [961, 966], [968, 973], [975, 980], [982, 987], [989, 994], [996, 1001], [1003, 1008], [1010, 1015], [1017, 1022], [1024, 1029], [1031, 1036], [1038, 1043], [1045, 1050], [1052, 1057], [1059, 1064], [1066, 1071], [1073, 1078], [1080, 1085], [1087, 1092], [1094, 1099], [1101, 1106], [1108, 1113], [1115, 1120], [1122, 1127], [1129, 1134], [1136, 1141], [1143, 1148], [1150, 1155], [1157, 1162], [1164, 1169], [1171, 1176], [1178, 1183], [1185, 1190], [1192, 1197], [1199, 1204], [1206, 1211], [1213, 1218], [1220, 1225], [1227, 1232], [1234, 1239], [1241, 1246], [1248, 1253], [1255, 1260], [1262, 1267], [1269, 1274], [1276, 1281], [1283, 1288], [1290, 1295], [1297, 1302], [1304, 1309], [1311, 1316], [1318, 1323], [1325, 1330], [1332, 1337], [1339, 1344], [1346, 1351], [1353, 1358], [1360, 1365], [1367, 1372], [1374, 1379], [1381, 1386], [1388, 1393], [1395, 1400], [1402, 1407], [1409, 1414], [1416, 1421], [1423, 1428], [1430, 1435], [1437, 1442], [1444, 1449], [1451, 1456], [1458, 1463], [1465, 1470], [1472, 1477], [1479, 1484], [1486, 1491], [1493, 1498], [1500, 1505], [1507, 1512], [1514, 1519], [1521, 1526], [1528, 1533], [1535, 1540], [1542, 1547], [1549, 1554], [1556, 1561], [1563, 1568], [1570, 1575], [1577, 1582], [1584, 1589], [1591, 1596], [1598, 1603], [1605, 1610], [1612, 1617], [1619, 1624], [1626, 1631], [1633, 1638], [1640, 1645], [1647, 1652], [1654, 1659], [1661, 1666], [1668, 1673], [1675, 1680], [1682, 1687], [1689, 1694], [1696, 1701], [1703, 1708], [1710, 1715], [1717, 1722], [1724, 1729], [1731, 1736], [1738, 1743], [1745, 1750], [1752, 1757], [1759, 1764], [1766, 1771], [1773, 1778], [1780, 1785], [1787, 1792], [1794, 1799], [1801, 1806], [1808, 1813], [1815, 1820], [1822, 1827], [1829, 1834], [1836, 1841], [1843, 1848], [1850, 1855], [1857, 1862], [1864, 1869], [1871, 1876], [1878, 1883], [1885, 1890], [1892, 1897], [1899, 1904], [1906, 1911], [1913, 1918], [1920, 1925], [1927, 1932], [1934, 1939], [1941, 1946], [1948, 1953], [1955, 1960], [1962, 1967], [1969, 1974], [1976, 1981], [1983, 1988], [1990, 1995], [1997, 2002], [2004, 2009], [2011, 2016], [2018, 2023], [2025, 2030], [2032, 2037], [2039, 2044], [2046, 2051], [2053, 2058], [2060, 2065], [2067, 2072], [2074, 2079], [2081, 2086], [2088, 2093], [2095, 2100], [2102, 2107], [2109, 2114], [2116, 2121], [2123, 2128], [2130, 2135], [2137, 2142], [2144, 2149], [2151, 2156], [2158, 2163], [2165, 2170], [2172, 2177], [2179, 2184], [2186, 2191], [2193, 2198], [2200, 2205], [2207, 2212], [2214, 2219], [2221, 2226], [2228, 2233], [2235, 2240], [2242, 2247], [2249, 2254], [2256, 2261], [2263, 2268], [2270, 2275], [2277, 2282], [2284, 2289], [2291, 2296], [2298, 2303], [2305, 2310], [2312, 2317], [2319, 2324], [2326, 2331], [2333, 2338], [2340, 2345], [2347, 2352], [2354, 2359], [2361, 2366], [2368, 2373], [2375, 2380], [2382, 2387], [2389, 2394], [2396, 2401], [2403, 2408], [2410, 2415], [2417, 2422], [2424, 2429], [2431, 2436], [2438, 2443], [2445, 2450], [2452, 2457], [2459, 2464], [2466, 2471], [2473, 2478], [2480, 2485], [2487, 2492], [2494, 2499], [2501, 2506], [2508, 2513], [2515, 2520], [2522, 2527], [2529, 2534], [2536, 2541], [2543, 2548], [2550, 2555], [2557, 2562], [2564, 2569], [2571, 2576], [2578, 2583], [2585, 2590], [2592, 2597], [2599, 2604], [2606, 2611], [2613, 2618], [2620, 2625], [2627, 2632], [2634, 2639], [2641, 2646], [2648, 2653], [2655, 2660], [2662, 2667], [2669, 2674], [2676, 2681], [2683, 2688], [2690, 2695], [2697, 2702], [2704, 2709], [2711, 2716], [2718, 2723], [2725, 2730], [2732, 2737], [2739, 2744], [2746, 2751], [2753, 2758], [2760, 2765], [2767, 2772], [2774, 2779], [2781, 2786], [2788, 2793], [2795, 2800], [2802, 2807], [2809, 2814], [2816, 2821], [2823, 2828], [2830, 2835], [2837, 2842], [2844, 2849], [2851, 2856], [2858, 2863], [2865, 2870], [2872, 2877], [2879, 2884], [2886, 2891], [2893, 2898], [2900, 2905], [2907, 2912], [2914, 2919], [2921, 2926], [2928, 2933], [2935, 2940], [2942, 2947], [2949, 2954], [2956, 2961], [2963, 2968], [2970, 2975], [2977, 2982], [2984, 2989], [2991, 2996], [2998, 3003], [3005, 3010], [3012, 3017], [3019, 3024], [3026, 3031], [3033, 3038], [3040, 3045], [3047, 3052], [3054, 3059], [3061, 3066], [3068, 3073], [3075, 3080], [3082, 3087], [3089, 3094], [3096, 3101], [3103, 3108], [3110, 3115], [3117, 3122], [3124, 3129], [3131, 3136], [3138, 3143], [3145, 3150], [3152, 3157], [3159, 3164], [3166, 3171], [3173, 3178], [3180, 3185], [3187, 3192], [3194, 3199], [3201, 3206], [3208, 3213], [3215, 3220], [3222, 3227], [3229, 3234], [3236, 3241], [3243, 3248], [3250, 3255], [3257, 3262], [3264, 3269], [3271, 3276], [3278, 3283], [3285, 3290], [3292, 3297], [3299, 3304], [3306, 3311], [3313, 3318], [3320, 3325], [3327, 3332], [3334, 3339], [3341, 3346], [3348, 3353], [3355, 3360], [3362, 3367], [3369, 3374], [3376, 3381]]}, "text": "/-\nCopyright (c) 2022 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\nimport Mathlib.Algebra.Associated\nimport Mathlib.NumberTheory.Divisors\n\n#align_import algebra.is_prime_pow from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n/-!\n# Prime powers\n\nThis file deals with prime powers: numbers which are positive integer powers of a single prime.\n-/\n\n\nvariable {R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)\n\n/-- `n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. -/\ndef IsPrimePow : Prop :=\n  \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n\n#align is_prime_pow IsPrimePow\n\ntheorem isPrimePow_def : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n :=\n  Iff.rfl\n#align is_prime_pow_def isPrimePow_def\n\n/-- An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a\nnatural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem isPrimePow_iff_pow_succ : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 p ^ (k + 1) = n :=\n  (isPrimePow_def _).trans\n    \u27e8fun \u27e8p, k, hp, hk, hn\u27e9 => \u27e8_, _, hp, by rwa [Nat.sub_add_cancel hk]\u27e9, fun \u27e8p, k, hp, hn\u27e9 =>\n      \u27e8_, _, hp, Nat.succ_pos', hn\u27e9\u27e9\n#align is_prime_pow_iff_pow_succ isPrimePow_iff_pow_succ\n\ntheorem not_isPrimePow_zero [NoZeroDivisors R] : \u00acIsPrimePow (0 : R) := by\n  simp only [isPrimePow_def, not_exists, not_and', and_imp]\n  intro x n _hn hx\n  rw [pow_eq_zero hx]\n  simp\n#align not_is_prime_pow_zero not_isPrimePow_zero\n\ntheorem IsPrimePow.not_unit {n : R} (h : IsPrimePow n) : \u00acIsUnit n :=\n  let \u27e8_p, _k, hp, hk, hn\u27e9 := h\n  hn \u25b8 (isUnit_pow_iff hk.ne').not.mpr hp.not_unit\n#align is_prime_pow.not_unit IsPrimePow.not_unit\n\ntheorem IsUnit.not_isPrimePow {n : R} (h : IsUnit n) : \u00acIsPrimePow n := fun h' => h'.not_unit h\n#align is_unit.not_is_prime_pow IsUnit.not_isPrimePow\n\ntheorem not_isPrimePow_one : \u00acIsPrimePow (1 : R) :=\n  isUnit_one.not_isPrimePow\n#align not_is_prime_pow_one not_isPrimePow_one\n\ntheorem Prime.isPrimePow {p : R} (hp : Prime p) : IsPrimePow p :=\n  \u27e8p, 1, hp, zero_lt_one, by simp\u27e9\n#align prime.is_prime_pow Prime.isPrimePow\n\ntheorem IsPrimePow.pow {n : R} (hn : IsPrimePow n) {k : \u2115} (hk : k \u2260 0) : IsPrimePow (n ^ k) :=\n  let \u27e8p, k', hp, hk', hn\u27e9 := hn\n  \u27e8p, k * k', hp, mul_pos hk.bot_lt hk', by rw [pow_mul', hn]\u27e9\n#align is_prime_pow.pow IsPrimePow.pow\n\ntheorem IsPrimePow.ne_zero [NoZeroDivisors R] {n : R} (h : IsPrimePow n) : n \u2260 0 := fun t =>\n  not_isPrimePow_zero (t \u25b8 h)\n#align is_prime_pow.ne_zero IsPrimePow.ne_zero\n\ntheorem IsPrimePow.ne_one {n : R} (h : IsPrimePow n) : n \u2260 1 := fun t =>\n  not_isPrimePow_one (t \u25b8 h)\n#align is_prime_pow.ne_one IsPrimePow.ne_one\n\nsection Nat\n\ntheorem isPrimePow_nat_iff (n : \u2115) : IsPrimePow n \u2194 \u2203 p k : \u2115, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n := by\n  simp only [isPrimePow_def, Nat.prime_iff]\n#align is_prime_pow_nat_iff isPrimePow_nat_iff\n\ntheorem Nat.Prime.isPrimePow {p : \u2115} (hp : p.Prime) : IsPrimePow p :=\n  _root_.Prime.isPrimePow (prime_iff.mp hp)\n#align nat.prime.is_prime_pow Nat.Prime.isPrimePow\n\ntheorem isPrimePow_nat_iff_bounded (n : \u2115) :\n    IsPrimePow n \u2194 \u2203 p : \u2115, p \u2264 n \u2227 \u2203 k : \u2115, k \u2264 n \u2227 p.Prime \u2227 0 < k \u2227 p ^ k = n := by\n  rw [isPrimePow_nat_iff]\n  refine' Iff.symm \u27e8fun \u27e8p, _, k, _, hp, hk, hn\u27e9 => \u27e8p, k, hp, hk, hn\u27e9, _\u27e9\n  rintro \u27e8p, k, hp, hk, rfl\u27e9\n  refine' \u27e8p, _, k, (Nat.lt_pow_self hp.one_lt _).le, hp, hk, rfl\u27e9\n  conv => { lhs; rw [\u2190 (pow_one p)] }\n  exact pow_le_pow_right hp.one_lt.le hk\n#align is_prime_pow_nat_iff_bounded isPrimePow_nat_iff_bounded\n\ninstance {n : \u2115} : Decidable (IsPrimePow n) :=\n  decidable_of_iff' _ (isPrimePow_nat_iff_bounded n)\n\ntheorem IsPrimePow.dvd {n m : \u2115} (hn : IsPrimePow n) (hm : m \u2223 n) (hm\u2081 : m \u2260 1) : IsPrimePow m := by\n  rw [isPrimePow_nat_iff] at hn \u22a2\n  rcases hn with \u27e8p, k, hp, _hk, rfl\u27e9\n  obtain \u27e8i, hik, rfl\u27e9 := (Nat.dvd_prime_pow hp).1 hm\n  refine' \u27e8p, i, hp, _, rfl\u27e9\n  apply Nat.pos_of_ne_zero\n  rintro rfl\n  simp only [pow_zero, ne_eq, not_true_eq_false] at hm\u2081\n#align is_prime_pow.dvd IsPrimePow.dvd\n\ntheorem Nat.disjoint_divisors_filter_isPrimePow {a b : \u2115} (hab : a.Coprime b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\n\nexample {a b : \u2115} (n : gcd a b \u2223 1) (n : 1 \u2223 gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.dvd_antisymm; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H : gcd a b \u2223 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_one_of_dvd_one; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.gcd_eq_one; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Coprime b a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.symm; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k : \u2115) (H1 : a \u2223 k) (H2 : Coprime k b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.coprime_dvd_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (H1 : b \u2223 m) (H2 : Coprime a m) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.coprime_dvd_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k : \u2115) (H : Coprime (k * a) b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k : \u2115) (H : Coprime (a * k) b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k : \u2115) (H : Coprime a (k * b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_left_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k : \u2115) (H : Coprime a (b * k)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.coprime_mul_right_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (H : Coprime (gcd a b) m) (d : gcd a b \u2223 m) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.eq_one_of_dvd<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (p : List.Pairwise Coprime (a :: l)) (z : b \u2208 l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.rel_of_pairwise_cons<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (h\u2081 : \u2200 x \u2208 l, Coprime x x) (h\u2082 : List.Pairwise Coprime l) (h\u2083 : List.Pairwise (flip Coprime) l) (s : a \u2208 l) (s : b \u2208 l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Pairwise.forall_of_forall_of_flip<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (o : Option \u2115) (ha : gcd a b \u2208 o) (hb : 1 \u2208 o) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Option.mem_unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t\u2081 : List \u2115) (t\u2082 : List \u2115) (H : gcd a b :: t\u2081 = 1 :: t\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.head_eq_of_cons_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : gcd a b \u2208 [1]) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.eq_of_mem_singleton; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (s : List.concat l (gcd a b) = List.concat l 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.last_eq_of_concat_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : b \u2208 []) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.forall_mem_nil; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (h : gcd a b \u2208 List.replicate n 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.eq_of_mem_replicate<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.6893428) (xs : List ?\u03b1\u271d) (h\u2080 : gcd a b < List.length xs) (h\u2081 : List.Nodup xs) (h\u2082 : List.get? xs (gcd a b) = List.get? xs 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.get?_inj<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (p : List.Chain Coprime a (b :: l)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.rel_of_chain_cons<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H0 : \u2200 (n : \u2115), Coprime 0 n) (H1 : \u2200 (m n : \u2115), 0 < m \u2192 Coprime (n % m) m \u2192 Coprime m n) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.gcd.induction<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (pred : \u2200 (i : \u2115), testBit (gcd a b) i = testBit 1 i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_of_testBit_eq; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (lb : Option \u2115) (cut : \u2115 \u2192 Ordering) (t : Std.RBNode \u2115) (hp : Std.RBNode.All (Coprime a) t) (H : \u2200 {x : \u2115}, x \u2208 lb \u2192 Coprime a x) (n : Std.RBNode.lowerBound? cut t lb = some b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Std.RBNode.All.lowerBound?_lb<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (cut : \u2115 \u2192 Ordering) (t : Std.RBNode \u2115) (hp : Std.RBNode.All (Coprime a) t) (x : Std.RBNode.lowerBound? cut t none = some b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Std.RBNode.All.lowerBound?<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hmn : gcd a b < 1 + 1) (h : \u00acgcd a b < 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_of_lt_succ_of_not_lt<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h\u2081 : 1 \u2264 gcd a b) (h\u2082 : gcd a b < 1 + 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_of_le_of_lt_succ<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : 0 < gcd a b) (t : 0 < 1) (t : pred (gcd a b) = pred 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.pred_inj; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (np : 0 < n) (h : n * gcd a b = n * 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.mul_left_cancel<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (mp : 0 < m) (h : gcd a b * m = 1 * m) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.mul_right_cancel<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : Coprime a b \u2194 True) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply of_iff_true; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Prop) (h : Coprime a b) (z : \u03b2) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply imp_intro<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : Prop) (n : Prop) (c : Prop) (h\u2080 : c \u2192 n) (h\u2081 : n \u2192 Coprime a b) (g : n \u2192 n) (g : c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply imp_imp_imp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : Prop) (h : m \u2228 Coprime a b) (na : \u00acm) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Or.resolve_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : Prop) (h : \u00acc \u2228 Coprime a b) (ha : c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Or.neg_resolve_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : Prop) (h : Coprime a b \u2228 y) (nb : \u00acy) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Or.resolve_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : Prop) (h : Coprime a b \u2228 \u00acr) (nb : r) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Or.neg_resolve_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : \u2115 \u2192 Prop) (h : \u2200 (a_1 : \u2115), p a_1 \u2192 Coprime a a_1) (v : \u2200 (a : \u2115), p a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply forall_imp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : \u00acCoprime a b \u2192 False) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Decidable.by_contra; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : Prop) (h : \u00ac(Coprime a b \u2192 e)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Decidable.of_not_imp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Prop) (h : \u00acCoprime a b \u2192 t) (hb : \u00act) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Decidable.not_imp_symm<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : Prop) (d : (Coprime a b \u2192 d) \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Decidable.peirce<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H : \u2200 (b_1 : Prop), (Coprime a b \u2192 b_1) \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply peirce'; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7063120) (f : \u2115 \u2192 ?\u03b2) (p : ?\u03b2 \u2192 Prop) (h : \u2200 (a : \u2115), ?p (?f a)) (hf : Function.Injective f) (m : Subtype.coind f h (gcd a b) = Subtype.coind f h 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Subtype.coind_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (z : { down := gcd a b } = { down := 1 }) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply PLift.up_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : { down := gcd a b } = { down := 1 }) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply ULift.up_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Multiset \u2115) (H : Symmetric Coprime) (hs : Multiset.Pairwise Coprime s) (t : a \u2208 s) (t : b \u2208 s) (t : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.Pairwise.forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7088417) (f : \u2115 \u2192 ?\u03b2) (s : Multiset \u2115) (m : Multiset.Nodup (Multiset.map f s)) (m : gcd a b \u2208 s) (m : 1 \u2208 s) (m : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.inj_on_of_nodup_map<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (s : gcd a b \u2208 Multiset.replicate n 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.eq_of_mem_replicate<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (hn : n \u2260 0) (m : Multiset.replicate n (gcd a b) = Multiset.replicate n 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.replicate_right_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : ?\u03b1) (\u03b1 : Type ?u.7094620) (t : (fun x => Multiset.replicate x y) (gcd a b) = (fun x => Multiset.replicate x y) 1) (t : \u03b1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.replicate_left_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7096556) (l : List ?\u03b1) (h : gcd a b \u2208 Multiset.map (Function.const \u03b1 1) \u2191l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.eq_of_mem_map_const<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Multiset \u2115) (h : b \u2208 Multiset.filter (Coprime a) s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.of_mem_filter<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7105427) (f : ?\u03b1 \u2192 \u2115) (m : Multiset ?\u03b1) (h : Set.Pairwise {a | a \u2208 m} fun a\u2081 a\u2082 => Coprime (f a\u2081) (f a\u2082)) (c : a \u2208 {b | b \u2208 Multiset.map f m}) (c : b \u2208 {b | b \u2208 Multiset.map f m}) (c : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.map_set_pairwise<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (h : gcd a b \u2261 1 [MOD m]) (h2 : |\u21911 - \u2191(gcd a b)| < \u2191m) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.ModEq.eq_of_abs_lt<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (h : gcd a b \u2261 1 [MOD m]) (ha : gcd a b < m) (hb : 1 < m) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.ModEq.eq_of_lt_of_lt<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115) (h : a * r \u2261 1 [MOD b]) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.coprime_of_mul_modEq_one<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (hx : 2 \u2264 x) (e : (fun x => x ^ x) (gcd a b) = (fun x => x ^ x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.pow_right_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (hm : m \u2260 0) (w : (fun x => x ^ m) (gcd a b) = (fun x => x ^ m) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.pow_left_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (ha : gcd a b \u2260 0) (hb : 1 \u2260 0) (h : List.Perm (factors (gcd a b)) (factors 1)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_of_perm_factors<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H : \u2200 (k : \u2115), Prime k \u2192 k \u2223 a \u2192 \u00ack \u2223 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.coprime_of_dvd; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H : \u2200 (k : \u2115), Prime k \u2192 k \u2223 a \u2192 k \u2223 b \u2192 k \u2223 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.coprime_of_dvd'; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (h : Prime (x ^ gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Prime.eq_one_of_pow<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n_pos : 0 < b) (hlt : b < a) (pp : Prime a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.coprime_of_lt_prime<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : succ (gcd a b) = succ 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.succ_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : gcd a b \u2223 1) (h : 1 / gcd a b = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_of_dvd_of_div_eq_one<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (n : \u2115) (s : gcd a b \u2208 \u2191(Finset.Ico n (n + n))) (s : 1 \u2208 \u2191(Finset.Ico n (n + n))) (s : (fun x => x % n) (gcd a b) = (fun x => x % n) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.mod_injOn_Ico<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n) (hP : \u00acBddAbove {x | Coprime a x}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.decreasing_induction_of_not_bddAbove<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n) (hP : Set.Infinite {x | Coprime a x}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.decreasing_induction_of_infinite<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (seed : \u2115) (h : \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n) (hs : Coprime a seed) (hi : \u2200 (x : \u2115), seed \u2264 x \u2192 Coprime a x \u2192 \u2203 y, x < y \u2227 Coprime a y) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.cauchy_induction'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (seed : \u2115) (f : \u2115 \u2192 \u2115) (h : \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n) (hs : Coprime a seed) (hf : \u2200 (x : \u2115), seed \u2264 x \u2192 Coprime a x \u2192 x < f x \u2227 Coprime a (f x)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.cauchy_induction<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k : \u2115) (seed : \u2115) (h : \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n) (hk : 1 < k) (hs : Coprime a (succ seed)) (hm : \u2200 (x : \u2115), seed < x \u2192 Coprime a x \u2192 Coprime a (k * x)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.cauchy_induction_mul<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (seed : \u2115) (h : \u2200 (n : \u2115), Coprime a (n + 1) \u2192 Coprime a n) (hs : Coprime a (succ seed)) (hm : \u2200 (x : \u2115), seed < x \u2192 Coprime a x \u2192 Coprime a (2 * x)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.cauchy_induction_two_mul<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : (fun x x_1 => x \u2223 x_1) (gcd a b) = (fun x x_1 => x \u2223 x_1) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.dvd_left_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (H : gcd a b * n = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_one_of_mul_eq_one_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (H : m * gcd a b = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_one_of_mul_eq_one_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (ha : \u2200 (a : \u2115), Coprime (a + 1) (a + 1)) (hb : \u2200 (b : \u2115), Coprime 0 (b + 1)) (hd : \u2200 (a b : \u2115), a < b \u2192 Coprime (a + 1) b \u2192 Coprime a (b + 1) \u2192 Coprime (a + 1) (b + 1)) (e : a < b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.diag_induction<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k : \u2115) (hk : k \u2208 Eq (gcd a b)) (h_ind : \u2200 k \u2208 Eq (gcd a b), k + 1 \u2208 Eq (gcd a b)) (hnk : k \u2264 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.set_induction_bounded<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hb : 0 \u2208 Eq (gcd a b)) (h_ind : \u2200 k \u2208 Eq (gcd a b), k + 1 \u2208 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.set_induction<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (h : findGreatest (Coprime a) n = b) (h0 : b \u2260 0) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.findGreatest_of_ne_zero<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b3 : Set \u2191(Eq (gcd a b))) (n : 1 \u2208 Lean.Internal.coeM \u03b3) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.coe_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b3 : Set \u2191(Eq (gcd a b))) (t : 1 \u2208 Subtype.val '' \u03b3) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image_val_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : Coprime b a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.Coprime.symmetric; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : \u2115) (w : \u2115) (h_ab_coprime : Coprime e w) (hka : gcd a b \u2223 e) (hkb : gcd a b \u2223 w) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.eq_one_of_dvd_coprimes<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : \u2115 \u2192 Type ?u.7153394) (t : (i : \u2115) \u2192 Set (?\u03b1 i)) (e : 1 \u2208 Sigma.fst '' Set.sigma (Eq (gcd a b)) t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.fst_image_sigma_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : instOfNatNat 1 \u2208 @OfNat.ofNat \u2115 1 \u207b\u00b9' Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mapsTo_preimage; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7156309) (\u03b2 : Type ?u.7156310) (s : Set ?\u03b1) (t : Set ?\u03b2) (f : ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115) (hs : Set.Subsingleton s) (ht : Set.Subsingleton t) (x : gcd a b \u2208 Set.image2 f s t) (x : 1 \u2208 Set.image2 f s t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subsingleton.image2<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (ha : gcd a b \u2208 Set.uIcc 1 c) (hb : 1 \u2208 Set.uIcc (gcd a b) c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eq_of_mem_uIcc_of_mem_uIcc<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (z : gcd a b \u2208 Set.uIcc g 1) (z : 1 \u2208 Set.uIcc g (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eq_of_mem_uIcc_of_mem_uIcc'; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (y : (fun b => Set.uIcc b m) (gcd a b) = (fun b => Set.uIcc b m) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.uIcc_injective_right; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : \u2115) (m : Set.uIcc w (gcd a b) = Set.uIcc w 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.uIcc_injective_left; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (e : gcd a b \u2208 \u0399 1 c) (e : 1 \u2208 \u0399 (gcd a b) c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eq_of_mem_uIoc_of_mem_uIoc<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (z : gcd a b \u2208 \u0399 c 1) (z : 1 \u2208 \u0399 c (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eq_of_mem_uIoc_of_mem_uIoc'; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (ha : gcd a b \u2264 c) (hb : 1 \u2264 c) (r : gcd a b \u2209 \u0399 1 c) (r : 1 \u2209 \u0399 (gcd a b) c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eq_of_not_mem_uIoc_of_not_mem_uIoc<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : \u2115) (c : (fun b => \u0399 b e) (gcd a b) = (fun b => \u0399 b e) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.uIoc_injective_right; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115) (m : \u0399 r (gcd a b) = \u0399 r 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.uIoc_injective_left; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (y : \u2115) (h : Set.OrdConnected (Eq (gcd a b))) (c : x \u2208 Eq (gcd a b)) (c : y \u2208 Eq (gcd a b)) (c : 1 \u2208 Set.Icc x y) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.OrdConnected.out<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (y : \u2115) (hs : Set.OrdConnected (Eq (gcd a b))) (hx : x \u2208 Eq (gcd a b)) (hy : y \u2208 Eq (gcd a b)) (g : 1 \u2208 Set.uIcc x y) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.OrdConnected.uIcc_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (y : \u2115) (hs : Set.OrdConnected (Eq (gcd a b))) (hx : x \u2208 Eq (gcd a b)) (hy : y \u2208 Eq (gcd a b)) (r : 1 \u2208 \u0399 x y) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.OrdConnected.uIoc_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7171321) (t : Set ?\u03b2) (x : 1 \u2208 Prod.fst '' Eq (gcd a b) \u00d7\u02e2 t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.fst_image_prod_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7171396) (s : Set ?\u03b1) (x : 1 \u2208 Prod.snd '' s \u00d7\u02e2 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.snd_image_prod_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (Y : Sort ?u.7172115) (f : \u2115 \u2192 ?Y) (w : toPullbackDiag f (gcd a b) = toPullbackDiag f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply injective_toPullbackDiag<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (H : Symmetric Coprime) (H\u2081 : \u2200 x \u2208 l, Coprime x x) (H\u2082 : List.Pairwise Coprime l) (r : a \u2208 l) (r : b \u2208 l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Pairwise.forall_of_forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (hR : Symmetric Coprime) (hl : List.Pairwise Coprime l) (r : a \u2208 l) (r : b \u2208 l) (r : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Pairwise.forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (hl : List.Pairwise Coprime l) (hr : Symmetric Coprime) (n : a \u2208 {x | x \u2208 l}) (n : b \u2208 {x | x \u2208 l}) (n : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Pairwise.set_pairwise<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (t : Set \u2115) (h : t \u2286 s) (hs : Set.Pairwise s Coprime) (v : a \u2208 t) (v : b \u2208 t) (v : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : Set \u2115) (H : r \u2264 Coprime) (hr : Set.Pairwise s r) (z : a \u2208 s) (z : b \u2208 s) (z : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.mono'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (h : Set.Subsingleton s) (d : a \u2208 s) (d : b \u2208 s) (d : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subsingleton.pairwise<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : a \u2208 \u2205) (y : b \u2208 \u2205) (y : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.pairwise_empty; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : a \u2260 b) (r : a \u2208 {d}) (r : b \u2208 {d}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.pairwise_singleton; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : a \u2260 b) (s : Set \u2115) (hs : Set.Pairwise s Coprime) (h : \u2200 b \u2208 s, d \u2260 b \u2192 Coprime d b \u2227 Coprime b d) (x : a \u2208 insert d s) (x : b \u2208 insert d s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.insert<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : a \u2260 b) (s : Set \u2115) (ha : r \u2209 s) (hs : Set.Pairwise s Coprime) (h : \u2200 b \u2208 s, Coprime r b \u2227 Coprime b r) (g : a \u2208 insert r s) (g : b \u2208 insert r s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.insert_of_not_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : a \u2260 b) (s : Set \u2115) (hs : Set.Pairwise s Coprime) (hr : Symmetric Coprime) (h : \u2200 b \u2208 s, g \u2260 b \u2192 Coprime g b) (c : a \u2208 insert g s) (c : b \u2208 insert g s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.insert_of_symmetric<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : a \u2260 b) (s : Set \u2115) (hs : Set.Pairwise s Coprime) (hr : Symmetric Coprime) (ha : s \u2209 s) (h : \u2200 b \u2208 s, Coprime s b) (y : a \u2208 insert s s) (y : b \u2208 insert s s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.insert_of_symmetric_of_not_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Type ?u.7188169) (f : ?\u03b9 \u2192 \u2115) (s : Set ?\u03b9) (h : Set.Pairwise s (Coprime on f)) (s : a \u2208 f '' s) (s : b \u2208 f '' s) (s : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.image<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7190595) (s : Set \u2115) (f : \u2115 \u2192 Set ?\u03b1) (w : ?\u03b1) (hs : Set.PairwiseDisjoint s f) (hi : gcd a b \u2208 s) (hj : 1 \u2208 s) (hai : w \u2208 f (gcd a b)) (haj : w \u2208 f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.PairwiseDisjoint.elim_set<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (t : List.Sorted Coprime (a :: l)) (t : b \u2208 l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.rel_of_sorted_cons<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (k : \u2115) (h : List.Sorted Coprime l) (hx : a \u2208 List.take k l) (hy : b \u2208 List.drop k l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Sorted.rel_of_mem_take_of_mem_drop<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (e : \u2115) (hba : e \u2264 g) (x : gcd a b \u2208 Set.Icc g e) (x : 1 \u2208 Set.Icc g e) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_Icc_of_ge<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set.Ici (gcd a b) = Set.Ici 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Ici_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : Set.Iic (gcd a b) = Set.Iic 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Iic_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (z : Set.Ioi (gcd a b) = Set.Ioi 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Ioi_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : Set.Iio (gcd a b) = Set.Iio 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Iio_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (g : s = Eq (gcd a b)) (g : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Eq.subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (hx : 1 \u2208 s) (h : s \u2286 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_of_mem_of_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : b \u2208 {x | Coprime a x}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Membership.mem.out; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : 1 \u2208 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subset.refl; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : 1 \u2208 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subset.rfl; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (d : Set \u2115) (ab : s \u2286 d) (bc : d \u2286 Eq (gcd a b)) (g : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subset.trans<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : \u2115) (hx : 1 = y) (h : y \u2208 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_of_eq_of_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s\u2081 : Set \u2115) (h : s\u2081 \u2286 Eq (gcd a b)) (c : 1 \u2208 s\u2081) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_of_subset_of_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (z : 1 \u2208 \u2205) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.empty_subset; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7230365) (x : ?\u03b1) (g : Set ?\u03b1) (c : Set ?\u03b1) (H\u2081 : x \u2208 g \u222a c) (H\u2082 : x \u2208 g \u2192 Coprime a b) (H\u2083 : x \u2208 c \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MemUnion.elim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (t : Set \u2115) (sr : s \u2286 Eq (gcd a b)) (tr : t \u2286 Eq (gcd a b)) (t : 1 \u2208 s \u222a t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.union_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : Set \u2115) (h : 1 \u2208 Eq (gcd a b) \u2229 g) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_of_mem_inter_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : Set \u2115) (h : 1 \u2208 r \u2229 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_of_mem_inter_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Set \u2115) (w : 1 \u2208 Eq (gcd a b) \u2229 t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.inter_subset_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (e : 1 \u2208 s \u2229 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.inter_subset_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : \u2115) (y : 1 \u2208 insert e (Eq (gcd a b))) (y : 1 \u2260 e) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_of_mem_insert_of_ne; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (s : gcd a b \u2208 insert 1 s) (s : gcd a b \u2209 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eq_of_not_mem_of_mem_insert<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : \u2115) (s : Set \u2115) (ha : d \u2208 Eq (gcd a b)) (hs : s \u2286 Eq (gcd a b)) (n : 1 \u2208 insert d s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.insert_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (s : Set \u2115) (H : \u2200 x \u2208 insert c s, Coprime a x) (h : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.forall_of_forall_insert<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : \u2115) (s : Set \u2115) (H : \u2200 x \u2208 s, Coprime a x) (ha : Coprime a d) (h : b \u2208 insert d s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.forall_insert_of_forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : gcd a b \u2208 {1}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eq_of_mem_singleton; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : {gcd a b} = {1}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.singleton_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H : gcd a b = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_singleton_of_eq; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : \u2115 \u2192 Prop) (y : 1 \u2208 {x | x \u2208 Eq (gcd a b) \u2227 p x}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.sep_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Set \u2115) (h : 1 \u2208 Eq (gcd a b) \\ t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_of_mem_diff<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Set \u2115) (w : 1 \u2208 Eq (gcd a b) \\ t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.diff_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : Set \u2115) (h : x \u2286 Eq (gcd a b)) (w : 1 \u2208 x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_powerset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : Set \u2115) (h : x \u2208 \ud835\udcab Eq (gcd a b)) (g : 1 \u2208 x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subset_of_mem_powerset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : Set \u2115) (s : y \u2264 Eq (gcd a b)) (s : y \u2208 \ud835\udcab y) (s : 1 \u2208 y) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.monotone_powerset; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (t : Set \u2115) (ht : Set.Subsingleton t) (hst : s \u2286 t) (x : gcd a b \u2208 s) (x : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subsingleton.anti<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : gcd a b \u2208 \u2205) (x : 1 \u2208 \u2205) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_empty; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (t : gcd a b \u2208 {x}) (t : 1 \u2208 {x}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_singleton<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115) (s : Set \u2115) (h : s \u2286 {r}) (x : gcd a b \u2208 s) (x : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_of_subset_singleton<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (g : \u2115) (h : \u2200 b \u2208 s, b = g) (x : gcd a b \u2208 s) (x : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_of_forall_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : gcd a b \u2208 {x | IsTop x}) (x : 1 \u2208 {x | IsTop x}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_isTop; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : gcd a b \u2208 {x | IsBot x}) (x : 1 \u2208 {x | IsBot x}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_isBot; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : \u2115) (hp : \u2200 (b : \u2115), Monotone fun a => a = b) (n : y \u2264 gcd a b) (n : 1 \u2208 (fun a => {b | a = b}) y) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.monotone_setOf<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (hp : \u2200 (b : \u2115), Antitone fun a => a = b) (x : gcd a b \u2264 x) (x : 1 \u2208 (fun a => {b | a = b}) x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.antitone_setOf<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : Set \u2115) (c : Set \u2115) (r : d \u2264 c) (r : \u2200 x \u2208 c, Coprime a x) (r : b \u2208 d) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.antitone_bforall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (u : Set \u2115) (h : s \u2286 Eq (gcd a b) \u222a u) (hac : Disjoint s u) (w : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Disjoint.subset_left_of_subset_union<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (t : Set \u2115) (h : s \u2286 t \u222a Eq (gcd a b)) (hab : Disjoint s t) (x : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Disjoint.subset_right_of_subset_union<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (h : List.Chain' Coprime (a :: b :: l)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Chain'.rel_head<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (h : List.Chain' Coprime (a :: l)) (hy : b \u2208 List.head? l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Chain'.rel_head?<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : \u2115) (r : \u2115 \u2192 \u2115 \u2192 Prop) (n : \u2115) (l : List \u2115) (h : List.Chain r s l) (hb : List.getLast (s :: l) (_ : s :: l \u2260 []) = n) (carries : \u2200 \u2983x y : \u2115\u2984, r x y \u2192 Coprime a y \u2192 Coprime a x) (final : Coprime a n) (d : b \u2208 s :: l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Chain.induction<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (d : \u2115) (l : List \u2115) (h : List.Chain r b l) (hb : List.getLast (b :: l) (_ : b :: l \u2260 []) = d) (carries : \u2200 \u2983x y : \u2115\u2984, r x y \u2192 Coprime a y \u2192 Coprime a x) (final : Coprime a d) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.Chain.induction_head<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l\u2081 : List \u2115) (l\u2082 : List \u2115) (w : List.Forall\u2082 Coprime l\u2081 l\u2082) (w : (a, b) \u2208 List.zip l\u2081 l\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.forall\u2082_zip<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : b \u2208 \u2205) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eqOn_empty; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (h : Set.EqOn (fun {b} => 1) (gcd a) s) (e : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.EqOn.symm<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (f\u2082 : \u2115 \u2192 \u2115) (h\u2081 : Set.EqOn (gcd a) f\u2082 s) (h\u2082 : Set.EqOn f\u2082 (fun {b} => 1) s) (z : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.EqOn.trans<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s\u2081 : Set \u2115) (s\u2082 : Set \u2115) (hs : s\u2081 \u2286 s\u2082) (hf : Set.EqOn (gcd a) (fun {b} => 1) s\u2082) (z : b \u2208 s\u2081) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.EqOn.mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s\u2081 : Set \u2115) (s\u2082 : Set \u2115) (h\u2081 : Set.EqOn (gcd a) (fun {b} => 1) s\u2081) (h\u2082 : Set.EqOn (gcd a) (fun {b} => 1) s\u2082) (w : b \u2208 s\u2081 \u222a s\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.EqOn.union<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set (OfNat \u2115 1)) (hf : Set.MapsTo (@OfNat.ofNat \u2115 1) s (Eq (gcd a b))) (z : instOfNatNat 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.subset_preimage<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (z : instOfNatNat 1 \u2208 \u2205) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mapsTo_empty; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7302863) (s : Set ?\u03b1) (f : ?\u03b1 \u2192 \u2115) (h : Set.MapsTo f s (Eq (gcd a b))) (r : 1 \u2208 f '' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.image_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set (OfNat \u2115 1)) (f\u2081 : OfNat \u2115 1 \u2192 \u2115) (h\u2081 : Set.MapsTo f\u2081 s (Eq (gcd a b))) (h : Set.EqOn f\u2081 (@OfNat.ofNat \u2115 1) s) (n : instOfNatNat 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.congr<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (t : Set (OfNat \u2115 1)) (h\u2081 : Set.MapsTo (@OfNat.ofNat \u2115 1) t (Eq (gcd a b))) (h\u2082 : Set.MapsTo OfNat.mk s t) (g : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.comp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : 1 \u2208 Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mapsTo_id; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s\u2081 : Set (OfNat \u2115 1)) (s\u2082 : Set (OfNat \u2115 1)) (t\u2081 : Set \u2115) (hf : Set.MapsTo (@OfNat.ofNat \u2115 1) s\u2081 t\u2081) (hs : s\u2082 \u2286 s\u2081) (ht : t\u2081 \u2286 Eq (gcd a b)) (s : instOfNatNat 1 \u2208 s\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s\u2081 : Set (OfNat \u2115 1)) (s\u2082 : Set (OfNat \u2115 1)) (hf : Set.MapsTo (@OfNat.ofNat \u2115 1) s\u2081 (Eq (gcd a b))) (hs : s\u2082 \u2286 s\u2081) (r : instOfNatNat 1 \u2208 s\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.mono_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set (OfNat \u2115 1)) (t\u2081 : Set \u2115) (hf : Set.MapsTo (@OfNat.ofNat \u2115 1) s t\u2081) (ht : t\u2081 \u2286 Eq (gcd a b)) (v : instOfNatNat 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.mono_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s\u2081 : Set (OfNat \u2115 1)) (s\u2082 : Set (OfNat \u2115 1)) (h\u2081 : Set.MapsTo (@OfNat.ofNat \u2115 1) s\u2081 (Eq (gcd a b))) (h\u2082 : Set.MapsTo (@OfNat.ofNat \u2115 1) s\u2082 (Eq (gcd a b))) (z : instOfNatNat 1 \u2208 s\u2081 \u222a s\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.union<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set (OfNat \u2115 1)) (hg : Set.MapsTo (@OfNat.ofNat \u2115 1) s (Eq (gcd a b))) (w : 1 \u2208 OfNat.mk \u207b\u00b9' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.MapsTo.comp_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7304017) (s : Set \u2115) (f : \u2115 \u2192 ?\u03b2) (hs : Set.Subsingleton s) (s : gcd a b \u2208 s) (s : 1 \u2208 s) (s : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subsingleton.injOn<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7304050) (f : \u2115 \u2192 ?\u03b2) (y : gcd a b \u2208 \u2205) (y : 1 \u2208 \u2205) (y : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.injOn_empty<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : \u2115) (\u03b2 : Type ?u.7304079) (f : \u2115 \u2192 ?\u03b2) (w : gcd a b \u2208 {d}) (w : 1 \u2208 {d}) (w : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.injOn_singleton<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7304206) (s : Set \u2115) (f\u2081 : \u2115 \u2192 ?\u03b2) (f\u2082 : \u2115 \u2192 ?\u03b2) (h\u2081 : Set.InjOn f\u2081 s) (h : Set.EqOn f\u2081 f\u2082 s) (t : gcd a b \u2208 s) (t : 1 \u2208 s) (t : f\u2082 (gcd a b) = f\u2082 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.InjOn.congr<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7304271) (s\u2081 : Set \u2115) (s\u2082 : Set \u2115) (f : \u2115 \u2192 ?\u03b2) (h : s\u2081 \u2286 s\u2082) (ht : Set.InjOn f s\u2082) (r : gcd a b \u2208 s\u2081) (r : 1 \u2208 s\u2081) (r : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.InjOn.mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7304380) (f : \u2115 \u2192 ?\u03b2) (s : Set \u2115) (h : Function.Injective f) (x : gcd a b \u2208 s) (x : 1 \u2208 s) (x : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.injOn_of_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (n : gcd a b \u2208 s) (n : 1 \u2208 s) (n : id (gcd a b) = id 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.injOn_id<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7304473) (\u03b3 : Type ?u.7304474) (s : Set \u2115) (t : Set ?\u03b2) (f : \u2115 \u2192 ?\u03b2) (g : ?\u03b2 \u2192 ?\u03b3) (hg : Set.InjOn g t) (hf : Set.InjOn f s) (h : Set.MapsTo f s t) (t : gcd a b \u2208 s) (t : 1 \u2208 s) (t : (g \u2218 f) (gcd a b) = (g \u2218 f) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.InjOn.comp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7304517) (\u03b3 : Type ?u.7304519) (s : Set ?\u03b1) (f : ?\u03b1 \u2192 \u2115) (g : \u2115 \u2192 ?\u03b3) (h : Set.InjOn (g \u2218 f) s) (m : gcd a b \u2208 f '' s) (m : 1 \u2208 f '' s) (m : g (gcd a b) = g 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.InjOn.image_of_comp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (f : \u2115 \u2192 \u2115) (s : Set \u2115) (n : \u2115) (h : Set.InjOn f s) (hf : Set.MapsTo f s s) (e : gcd a b \u2208 s) (e : 1 \u2208 s) (e : f^[n] (gcd a b) = f^[n] 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.InjOn.iterate<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7304622) (\u03b3 : Type ?u.7304624) (f : ?\u03b1 \u2192 \u2115) (g : \u2115 \u2192 ?\u03b3) (h : Function.Injective (g \u2218 f)) (w : gcd a b \u2208 Set.range f) (w : 1 \u2208 Set.range f) (w : g (gcd a b) = g 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective.injOn_range<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7304772) (s : Set \u2115) (f : \u2115 \u2192 ?\u03b2) (hf : Set.InjOn f s) (hs : Eq (gcd a b) \u2286 s) (h : 1 \u2208 s) (h\u2081 : f 1 \u2208 f '' Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.InjOn.mem_of_mem_image<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b3 : Type ?u.7304873) (s : Set \u2115) (t : Set \u2115) (g : \u2115 \u2192 ?\u03b3) (h : Set.EqOn (g \u2218 gcd a) (g \u2218 fun {b} => 1) s) (hg : Set.InjOn g t) (hf\u2081 : Set.MapsTo (gcd a) s t) (hf\u2082 : Set.MapsTo (fun {b} => 1) s t) (n : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.EqOn.cancel_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7306147) (s : Set ?\u03b1) (t : Set \u2115) (f : ?\u03b1 \u2192 \u2115) (hf : Set.EqOn (gcd a \u2218 f) ((fun {b} => 1) \u2218 f) s) (hf' : Set.SurjOn f s t) (s : b \u2208 t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.EqOn.cancel_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set (OfNat \u2115 1)) (h : Set.BijOn (@OfNat.ofNat \u2115 1) s (Eq (gcd a b))) (y : instOfNatNat 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.BijOn.mapsTo<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7306286) (s : Set \u2115) (t : Set ?\u03b2) (f : \u2115 \u2192 ?\u03b2) (h : Set.BijOn f s t) (v : gcd a b \u2208 s) (v : 1 \u2208 s) (v : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.BijOn.injOn<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7307135) (s : Set \u2115) (f : \u2115 \u2192 ?\u03b2) (f\u2081' : ?\u03b2 \u2192 \u2115) (h : Set.LeftInvOn f\u2081' f s) (w : gcd a b \u2208 s) (w : 1 \u2208 s) (w : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.LeftInvOn.injOn<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Set (OfNat \u2115 1)) (f : \u2115 \u2192 OfNat \u2115 1) (h : Set.LeftInvOn (@OfNat.ofNat \u2115 1) f (Eq (gcd a b))) (hf : Set.SurjOn f (Eq (gcd a b)) t) (c : instOfNatNat 1 \u2208 t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.LeftInvOn.mapsTo<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set (OfNat \u2115 1)) (f' : \u2115 \u2192 OfNat \u2115 1) (h : Set.RightInvOn f' (@OfNat.ofNat \u2115 1) (Eq (gcd a b))) (hf : Set.SurjOn f' (Eq (gcd a b)) s) (s : instOfNatNat 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.RightInvOn.mapsTo<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (t : Set \u2115) (f : \u2115 \u2192 \u2115) (h\u2081 : Set.LeftInvOn (gcd a) f s) (h\u2082 : Set.RightInvOn (fun {b} => 1) f t) (h : Set.MapsTo (fun {b} => 1) t s) (v : b \u2208 t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.eqOn_of_leftInvOn_of_rightInvOn<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7308684) (f : \u2115 \u2192 ?\u03b2) (y : 1 \u2208 Function.invFunOn f (Eq (gcd a b)) '' (f '' Eq (gcd a b))) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.invFunOn_image_image_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7313323) (\u03b3 : Type ?u.7313324) (f : \u2115 \u2192 ?\u03b2) (g : ?\u03b2 \u2192 ?\u03b3) (s : Set \u2115) (hg : Function.Injective g) (hf : Set.InjOn f s) (c : gcd a b \u2208 s) (c : 1 \u2208 s) (c : (g \u2218 f) (gcd a b) = (g \u2218 f) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective.comp_injOn<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7313657) (fa : ?\u03b1 \u2192 ?\u03b1) (fb : \u2115 \u2192 \u2115) (f : ?\u03b1 \u2192 \u2115) (s : Set ?\u03b1) (h : Function.Semiconj f fa fb) (ha : Set.InjOn fa s) (hf : Set.InjOn f (fa '' s)) (s : gcd a b \u2208 f '' s) (s : 1 \u2208 f '' s) (s : fb (gcd a b) = fb 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Semiconj.injOn_image<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7313700) (fa : ?\u03b1 \u2192 ?\u03b1) (fb : \u2115 \u2192 \u2115) (f : ?\u03b1 \u2192 \u2115) (h : Function.Semiconj f fa fb) (ha : Function.Injective fa) (hf : Set.InjOn f (Set.range fa)) (r : gcd a b \u2208 Set.range f) (r : 1 \u2208 Set.range f) (r : fb (gcd a b) = fb 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Semiconj.injOn_range<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7313860) (fa : \u2115 \u2192 \u2115) (fb : ?\u03b2 \u2192 ?\u03b2) (f : \u2115 \u2192 ?\u03b2) (s : Set ?\u03b2) (h : Function.Semiconj f fa fb) (hb : Set.InjOn fb s) (hf : Set.InjOn f (f \u207b\u00b9' s)) (x : gcd a b \u2208 f \u207b\u00b9' s) (x : 1 \u2208 f \u207b\u00b9' s) (x : fa (gcd a b) = fa 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Semiconj.injOn_preimage<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (t : gcd a b \u2208 s\u1d9c) (t : 1 \u2208 s\u1d9c) (t : (fun a => insert a s) (gcd a b) = (fun a => insert a s) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.insert_injOn<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7320561) (s : ?\u03b9 \u2192 Set \u2115) (h : \u2200 (i : \u03b9), 1 \u2208 s i) (g : Eq (gcd a b) \u2208 Set.range fun i => s i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_iInter_of_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7320588) (\u03ba : ?\u03b9 \u2192 Sort ?u.7320589) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (h : \u2200 (i : \u03b9) (j : \u03ba i), 1 \u2208 s i j) (s : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, s i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_iInter\u2082_of_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (z : Set \u2115) (\u03b2 : Type ?u.7320671) (f : \u2115 \u2192 ?\u03b2) (v : z \u2264 Eq (gcd a b)) (v : z \u2208 Set.kernImage f z) (v : f 1 = z) (v : \u03b2) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.kernImage_mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : ?\u03b2) (\u03b2 : Type ?u.7320800) (f : \u2115 \u2192 ?\u03b2) (d : t \u2208 (Set.range f)\u1d9c) (d : f 1 = t) (d : \u03b2) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.compl_range_subset_kernImage<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321304) (s : ?\u03b9 \u2192 Set \u2115) (h : \u2200 (i : \u03b9), s i \u2286 Eq (gcd a b)) (g : 1 \u2208 \u22c3 i, s i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iUnion_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321331) (\u03ba : ?\u03b9 \u2192 Sort ?u.7321332) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (h : \u2200 (i : \u03b9) (j : \u03ba i), s i j \u2286 Eq (gcd a b)) (r : 1 \u2208 \u22c3 i, \u22c3 j, s i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iUnion\u2082_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321366) (t : Set \u2115) (s : ?\u03b9 \u2192 Set \u2115) (h : \u2200 (i : \u03b9), t \u2286 s i) (v : 1 \u2208 t) (v : Eq (gcd a b) \u2208 Set.range fun i => s i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subset_iInter<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321397) (\u03ba : ?\u03b9 \u2192 Sort ?u.7321398) (s : Set \u2115) (t : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (h : \u2200 (i : \u03b9) (j : \u03ba i), s \u2286 t i j) (n : 1 \u2208 s) (n : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, t i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subset_iInter\u2082<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : 1 \u2208 \u22c2 i, Eq i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter_subset; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321692) (s : ?\u03b9 \u2192 Set \u2115) (i : ?\u03b9) (h : s i \u2286 Eq (gcd a b)) (n : 1 \u2208 \u22c2 i, s i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter_subset_of_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321761) (\u03ba : ?\u03b9 \u2192 Sort ?u.7321762) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (i : ?\u03b9) (j : ?\u03ba ?i) (h : s i j \u2286 Eq (gcd a b)) (x : 1 \u2208 \u22c2 i, \u22c2 j, s i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter\u2082_subset_of_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321902) (s : ?\u03b9 \u2192 Set \u2115) (t : ?\u03b9 \u2192 Set \u2115) (h : \u2200 (i : \u03b9), s i \u2286 t i) (m : 1 \u2208 \u22c2 i, s i) (m : Eq (gcd a b) \u2208 Set.range fun i => t i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter_mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321935) (s : ?\u03b9 \u2192 Set \u2115) (t : ?\u03b9 \u2192 Set \u2115) (h : \u2200 (i : \u03b9), s i \u2286 t i) (d : 1 \u2208 Set.iInter s) (d : Eq (gcd a b) \u2208 Set.range t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter_mono''<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7321968) (\u03ba : ?\u03b9 \u2192 Sort ?u.7321969) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (t : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (h : \u2200 (i : \u03b9) (j : \u03ba i), s i j \u2286 t i j) (t : 1 \u2208 \u22c2 i, \u22c2 j, s i j) (t : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, t i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter\u2082_mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7322093) (\u03b9' : Sort ?u.7322094) (s : ?\u03b9 \u2192 Set \u2115) (t : ?\u03b9' \u2192 Set \u2115) (h : \u2200 (j : \u03b9'), \u2203 i, s i \u2286 t j) (e : 1 \u2208 \u22c2 i, s i) (e : Eq (gcd a b) \u2208 Set.range fun j => t j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter_mono'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7322128) (\u03b9' : Sort ?u.7322129) (\u03ba : ?\u03b9 \u2192 Sort ?u.7322130) (\u03ba' : ?\u03b9' \u2192 Sort ?u.7322131) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (t : (i' : ?\u03b9') \u2192 ?\u03ba' i' \u2192 Set \u2115) (h : \u2200 (i' : \u03b9') (j' : \u03ba' i'), \u2203 i j, s i j \u2286 t i' j') (v : 1 \u2208 \u22c2 i, \u22c2 j, s i j) (v : Eq (gcd a b) \u2208 Set.range fun i' => \u22c2 j', t i' j') :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter\u2082_mono'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7322205) (s : ?\u03b9 \u2192 Set \u2115) (c : 1 \u2208 \u22c2 i, s i) (c : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 x, s i) (\u03ba : \u03b9 \u2192 Sort ?u.7322206) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iInter_subset_iInter\u2082<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7323353) (\u03b9' : Sort ?u.7323354) (s : ?\u03b9 \u2192 ?\u03b9' \u2192 Set \u2115) (x : 1 \u2208 \u22c3 j, \u22c2 i, s i j) (x : Eq (gcd a b) \u2208 Set.range fun i => \u22c3 j, s i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.iUnion_iInter_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7324580) (s : Set ?\u03b1) (t : ?\u03b1 \u2192 Set \u2115) (h : \u2200 x \u2208 s, 1 \u2208 t x) (c : Eq (gcd a b) \u2208 Set.range fun x => \u22c2 (_ : x \u2208 s), t x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_biInter<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (xs : gcd a b \u2208 s) (r : 1 \u2208 \u22c2 x \u2208 s, Eq x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.biInter_subset_of_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7324706) (s : Set ?\u03b1) (s' : Set ?\u03b1) (t : ?\u03b1 \u2192 Set \u2115) (h : s' \u2286 s) (z : 1 \u2208 \u22c2 x \u2208 s, t x) (z : Eq (gcd a b) \u2208 Set.range fun x => \u22c2 (_ : x \u2208 s'), t x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.biInter_subset_biInter_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7324780) (s : Set ?\u03b1) (s' : Set ?\u03b1) (t : ?\u03b1 \u2192 Set \u2115) (t' : ?\u03b1 \u2192 Set \u2115) (hs : s \u2286 s') (h : \u2200 x \u2208 s, t x \u2286 t' x) (v : 1 \u2208 \u22c2 x \u2208 s', t x) (v : Eq (gcd a b) \u2208 Set.range fun x => \u22c2 (_ : x \u2208 s), t' x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.biInter_mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (S : Set (Set \u2115)) (tS : Eq (gcd a b) \u2208 S) (e : 1 \u2208 \u22c2\u2080 S) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.sInter_subset_of_mem<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (S : Set (Set \u2115)) (h : \u2200 t' \u2208 S, t' \u2286 Eq (gcd a b)) (x : 1 \u2208 \u22c3\u2080 S) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.sUnion_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (S : Set (Set \u2115)) (t : Set \u2115) (h : \u2200 t' \u2208 S, t \u2286 t') (m : 1 \u2208 t) (m : Eq (gcd a b) \u2208 S) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subset_sInter<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (S : Set (Set \u2115)) (T : Set (Set \u2115)) (h : S \u2286 T) (c : 1 \u2208 \u22c2\u2080 T) (c : Eq (gcd a b) \u2208 S) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.sInter_subset_sInter<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7327602) (s : ?\u03b9 \u2192 Set (OfNat \u2115 1)) (t : ?\u03b9 \u2192 Set \u2115) (H : \u2200 (i : \u03b9), Set.MapsTo (@OfNat.ofNat \u2115 1) (s i) (t i)) (r : instOfNatNat 1 \u2208 \u22c2 i, s i) (r : Eq (gcd a b) \u2208 Set.range fun i => t i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mapsTo_iInter_iInter<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b9 : Sort ?u.7327641) (\u03ba : ?\u03b9 \u2192 Sort ?u.7327642) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set (OfNat \u2115 1)) (t : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set \u2115) (H : \u2200 (i : \u03b9) (j : \u03ba i), Set.MapsTo (@OfNat.ofNat \u2115 1) (s i j) (t i j)) (s : instOfNatNat 1 \u2208 \u22c2 i, \u22c2 j, s i j) (s : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, t i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mapsTo_iInter\u2082_iInter\u2082<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7327688) (\u03b9 : Sort ?u.7327690) (s : ?\u03b9 \u2192 Set ?\u03b1) (f : ?\u03b1 \u2192 \u2115) (n : 1 \u2208 f '' \u22c2 i, s i) (n : Eq (gcd a b) \u2208 Set.range fun i => f '' s i) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image_iInter_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7327719) (\u03b9 : Sort ?u.7327721) (\u03ba : ?\u03b9 \u2192 Sort ?u.7327722) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set ?\u03b1) (f : ?\u03b1 \u2192 \u2115) (z : 1 \u2208 f '' \u22c2 i, \u22c2 j, s i j) (z : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, f '' s i j) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image_iInter\u2082_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7327756) (S : Set (Set ?\u03b1)) (f : ?\u03b1 \u2192 \u2115) (z : 1 \u2208 f '' \u22c2\u2080 S) (z : Eq (gcd a b) \u2208 Set.range fun s => \u22c2 (_ : s \u2208 S), f '' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image_sInter_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7328017) (\u03b9 : Sort ?u.7328018) (s : ?\u03b9 \u2192 Set \u2115) (f : \u2115 \u2192 ?\u03b2) (hs : Directed (fun x x_1 => x \u2286 x_1) s) (hf : \u2200 (i : \u03b9), Set.InjOn f (s i)) (d : gcd a b \u2208 \u22c3 i, s i) (d : 1 \u2208 \u22c3 i, s i) (d : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.inj_on_iUnion_of_directed<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Set \u2115) (s : t \u2264 Eq (gcd a b)) (s : instOfNatNat 1 \u2208 @OfNat.ofNat \u2115 1 \u207b\u00b9' t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.monotone_preimage; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7329773) (\u03b2 : Type ?u.7329774) (\u03b9 : Sort ?u.7329776) (f : ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115) (s : ?\u03b9 \u2192 Set ?\u03b1) (t : Set ?\u03b2) (s : 1 \u2208 Set.image2 f (\u22c2 i, s i) t) (s : Eq (gcd a b) \u2208 Set.range fun i => Set.image2 f (s i) t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image2_iInter_subset_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7329810) (\u03b2 : Type ?u.7329811) (\u03b9 : Sort ?u.7329813) (f : ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115) (s : Set ?\u03b1) (t : ?\u03b9 \u2192 Set ?\u03b2) (g : 1 \u2208 Set.image2 f s (\u22c2 i, t i)) (g : Eq (gcd a b) \u2208 Set.range fun i => Set.image2 f s (t i)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image2_iInter_subset_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7329847) (\u03b2 : Type ?u.7329848) (\u03b9 : Sort ?u.7329850) (\u03ba : ?\u03b9 \u2192 Sort ?u.7329851) (f : ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115) (s : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set ?\u03b1) (t : Set ?\u03b2) (m : 1 \u2208 Set.image2 f (\u22c2 i, \u22c2 j, s i j) t) (m : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, Set.image2 f (s i j) t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image2_iInter\u2082_subset_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7329890) (\u03b2 : Type ?u.7329891) (\u03b9 : Sort ?u.7329893) (\u03ba : ?\u03b9 \u2192 Sort ?u.7329894) (f : ?\u03b1 \u2192 ?\u03b2 \u2192 \u2115) (s : Set ?\u03b1) (t : (i : ?\u03b9) \u2192 ?\u03ba i \u2192 Set ?\u03b2) (y : 1 \u2208 Set.image2 f s (\u22c2 i, \u22c2 j, t i j)) (y : Eq (gcd a b) \u2208 Set.range fun i => \u22c2 j, Set.image2 f s (t i j)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image2_iInter\u2082_subset_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (h : s \u2286 Eq (gcd a b)) (n : instOfNatNat 1 \u2208 @OfNat.ofNat \u2115 1 \u207b\u00b9' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.preimage_mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7332062) (f : ?\u03b1 \u2192 \u2115) (s : Set ?\u03b1) (h : \u2200 x \u2208 s, Coprime a (f x)) (d : b \u2208 f '' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.ball_image_of_ball<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7332115) (f : ?\u03b1 \u2192 \u2115) (s : Set ?\u03b1) (h : \u2200 x \u2208 s, Coprime a (f x)) (n : b \u2208 f '' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_image_elim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7332144) (f : ?\u03b1 \u2192 \u2115) (s : Set ?\u03b1) (h_y : b \u2208 f '' s) (h : \u2200 x \u2208 s, Coprime a (f x)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.mem_image_elim_on<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (f : \u2115 \u2192 OfNat \u2115 1) (I : Function.LeftInverse (@OfNat.ofNat \u2115 1) f) (c : instOfNatNat 1 \u2208 f '' Eq (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image_subset_preimage_of_inverse<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7333421) (f : ?\u03b1 \u2192 \u2115) (t : 1 \u2208 f '' (f \u207b\u00b9' Eq (gcd a b))) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.image_preimage_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : gcd a b \u2208 Set.range fun x => 1) (\u03b9 : Sort ?u.7335479) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.range_const_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7336211) (s : Set ?\u03b1) (f : ?\u03b1 \u2192 \u2115) (hs : Set.Subsingleton s) (x : gcd a b \u2208 f '' s) (x : 1 \u2208 f '' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subsingleton.image<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7336243) (s : Set ?\u03b2) (f : \u2115 \u2192 ?\u03b2) (hs : Set.Subsingleton s) (hf : Function.Injective f) (x : gcd a b \u2208 f \u207b\u00b9' s) (x : 1 \u2208 f \u207b\u00b9' s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Subsingleton.preimage<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7336276) (f : \u2115 \u2192 ?\u03b2) (s : Set \u2115) (hf : Function.Injective f) (hs : Set.Subsingleton (f '' s)) (x : gcd a b \u2208 s) (x : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_of_image<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7336308) (f : ?\u03b1 \u2192 \u2115) (s : Set \u2115) (hf : Function.Surjective f) (hs : Set.Subsingleton (f \u207b\u00b9' s)) (x : gcd a b \u2208 s) (x : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_of_preimage<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Set \u2191(Eq (gcd a b))) (v : 1 \u2208 Subtype.val '' t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Subtype.coe_image_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l\u2081 : List \u2115) (l\u2082 : List \u2115) (h : \u2200 x \u2208 l\u2081 \u222a l\u2082, Coprime a x) (g : b \u2208 l\u2081) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.forall_mem_of_forall_mem_union_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l\u2081 : List \u2115) (l\u2082 : List \u2115) (h : \u2200 x \u2208 l\u2081 \u222a l\u2082, Coprime a x) (w : b \u2208 l\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.forall_mem_of_forall_mem_union_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l\u2081 : List \u2115) (l\u2082 : List \u2115) (h : \u2200 x \u2208 l\u2081, Coprime a x) (t : b \u2208 l\u2081 \u2229 l\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.forall_mem_inter_of_forall_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l\u2082 : List \u2115) (l\u2081 : List \u2115) (h : \u2200 x \u2208 l\u2082, Coprime a x) (s : b \u2208 l\u2081 \u2229 l\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.forall_mem_inter_of_forall_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7341859) (f : \u2115 \u2192 ?\u03b2) (l : List \u2115) (d : List.Nodup (List.map f l)) (e : gcd a b \u2208 l) (e : 1 \u2208 l) (e : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.inj_on_of_nodup_map<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List \u2115) (hl\u2081 : \u2200 x \u2208 l, 1 \u2264 x) (hl\u2082 : List.prod l = 1) (hx : gcd a b \u2208 l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.all_one_of_le_one_le_of_prod_eq_one<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : succPNat (gcd a b) = succPNat 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.succPNat_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : (fun a => [a]) (gcd a b) = (fun a => [a]) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.singleton_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : \u2115) (l : List \u2115) (h : \u2200 x \u2208 e :: l, Coprime a x) (n : b \u2208 l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.forall_mem_of_forall_mem_cons<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (hn : n \u2260 0) (w : List.replicate n (gcd a b) = List.replicate n 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.replicate_right_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : ?\u03b1) (\u03b1 : Type ?u.7365342) (e : (fun x => List.replicate x t) (gcd a b) = (fun x => List.replicate x t) 1) (e : \u03b1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.replicate_left_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7369577) (xs : List ?\u03b1) (h\u2080 : gcd a b < List.length xs) (h\u2081 : List.Nodup xs) (h\u2082 : List.get? xs (gcd a b) = List.get? xs 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.get?_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7375743) (l : List ?\u03b1) (h : gcd a b \u2208 List.map (Function.const \u03b1 1) l) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.eq_of_mem_map_const<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : List (\u2115 \u2192 \u2115)) (f : \u2115 \u2192 \u2115) (hl : \u2200 f \u2208 l, Function.Injective f) (hf : Function.Injective f) (g : List.foldl Function.comp f l (gcd a b) = List.foldl Function.comp f l 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply List.injective_foldl_comp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : Option \u2115) (m : gcd a b \u2208 c) (m : 1 \u2208 c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Option.Mem.leftUnique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : some (gcd a b) = some 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Option.some_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : Fin (gcd a b) = Fin 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply fin_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (h : n \u2260 0) (y : Sym.replicate n (gcd a b) = Sym.replicate n 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Sym.replicate_right_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Sum.inl (gcd a b) = Sum.inl 1) (\u03b2 : Type ?u.7471993) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Sum.inl_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : Sum.inr (gcd a b) = Sum.inr 1) (\u03b1 : Type ?u.7472016) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Sum.inr_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset \u2115) (h : (Finset.filter (Coprime a) s).card = s.card) (hx : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.filter_card_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7496614) (s : Finset \u2115) (t : Finset ?\u03b2) (f : (a : \u2115) \u2192 a \u2208 ?s \u2192 ?\u03b2) (ha\u2081 : gcd a b \u2208 ?s) (ha\u2082 : 1 \u2208 ?s) (hf : \u2200 (a : \u2115) (ha : a \u2208 s), f a ha \u2208 t) (hsurj : \u2200 b \u2208 t, \u2203 a, \u2203 (ha : a \u2208 s), f a ha = b) (hst : s.card \u2264 t.card) (ha\u2081a\u2082 : f (gcd a b) ha\u2081 = f 1 ha\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.inj_on_of_surj_on_of_card_le<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset { x // Coprime a x }) (h : b \u2208 Finset.map (Function.Embedding.subtype fun x => Coprime a x) s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.property_of_mem_map_subtype<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset \u2191(Eq (gcd a b))) (g : 1 \u2208 \u2191(Finset.map (Function.Embedding.subtype fun x => x \u2208 Eq (gcd a b)) s)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.map_subtype_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (t : gcd a b \u2208 Finset.uIcc 1 c) (t : 1 \u2208 Finset.uIcc (gcd a b) c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.eq_of_mem_uIcc_of_mem_uIcc<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (s : gcd a b \u2208 Finset.uIcc c 1) (s : 1 \u2208 Finset.uIcc c (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.eq_of_mem_uIcc_of_mem_uIcc'; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : \u2115) (g : (fun b => Finset.uIcc b e) (gcd a b) = (fun b => Finset.uIcc b e) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.uIcc_injective_right; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (r : Finset.uIcc n (gcd a b) = Finset.uIcc n 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.uIcc_injective_left; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : gcd a b \u2208 {1}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.eq_of_mem_singleton; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : {gcd a b} = {1}) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.singleton_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : ?a \u2209 ?s) (s : Finset \u2115) (m : \u2115) (H : \u2200 x \u2208 Finset.cons m s h, Coprime a x) (h\u2082 : b \u2208 s) (h\u2082 : m \u2209 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.forall_of_forall_cons<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset \u2115) (ha : gcd a b \u2208 insert 1 s) (hb : gcd a b \u2209 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.eq_of_not_mem_of_mem_insert<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset \u2115) (n : gcd a b \u2208 (\u2191s)\u1d9c) (n : 1 \u2208 (\u2191s)\u1d9c) (n : (fun a => insert a s) (gcd a b) = (fun a => insert a s) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.insert_inj_on<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset \u2115) (hs : gcd a b \u2208 s) (hsa : gcd a b \u2209 Finset.erase s 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.eq_of_mem_of_not_mem_erase<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset \u2115) (r : gcd a b \u2208 \u2191s) (r : 1 \u2208 \u2191s) (r : Finset.erase s (gcd a b) = Finset.erase s 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.erase_injOn<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (s : Finset \u2115) (H : \u2200 x \u2208 insert n s, Coprime a x) (h : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.forall_of_forall_insert<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : { fst := { fst := a, snd := b },) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply sigma_mk_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1\u2082 : Type ?u.7556442) (\u03b2\u2082 : ?\u03b1\u2082 \u2192 Type ?u.7556444) (f\u2081 : (_ : \u2115) \u00d7' \u2115 \u2192 ?\u03b1\u2082) (f\u2082 : (a : (_ : \u2115) \u00d7' \u2115) \u2192 \u2115 \u2192 ?\u03b2\u2082 (?f\u2081 a)) (h : Function.Injective (Sigma.map f\u2081 f\u2082)) (s : f\u2082 { fst := a, snd := b }) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective.of_sigma_map<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : \u2124) (h : 1 < Int.natAbs e) (n : (fun x => e ^ x) (gcd a b) = (fun x => e ^ x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Int.pow_right_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : ?\u03b1) (\u03b1 : Type ?u.7566974) (d : (r, gcd a b) = (r, 1)) (d : \u03b1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Prod.mk.inj_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7566999) (s : ?\u03b2) (v : (fun a => (a, s)) (gcd a b) = (fun a => (a, s)) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Prod.mk.inj_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : Prop) (x : \u00acCoprime a b \u2192 \u00acp) (x : p) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Tactic.Contrapose.mtr<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7769981) (h\u2081 : Subsingleton \u03b1 \u2192 Coprime a b) (h\u2082 : Nontrivial \u03b1 \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (z : Mathlib.Meta.NormNum.IsNat (gcd a b) n) (z : \u2191n = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.IsNat.to_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : Mathlib.Meta.NormNum.IsNat (gcd a b) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.IsNat.to_raw_eq; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n' : \u2115) (w : Mathlib.Meta.NormNum.IsNat b n') (w : Coprime a n') :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.isNat.natElim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (t : Mathlib.Meta.NormNum.IsNat (gcd a b) c) (t : Mathlib.Meta.NormNum.IsNat 1 c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Meta.NormNum.isNat_eq_true<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : Mathlib.Meta.NormNum.IsNat (gcd a b) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Tactic.Ring.cast_pos; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (x : gcd a b = c) (x : 1 = c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Mathlib.Tactic.Ring.of_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : ?\u03b1 \u2192 Sort ?u.7791562) (\u03b1 : Type ?u.7791561) (R : ?\u03b1 \u2192 \u2115 \u2192 Prop) (h : Relator.RightTotal R) (y : (R \u21d2 fun x x_1 => x \u2192 x_1) n (Coprime a)) (y : (i : \u03b1) \u2192 n i) (y : \u03b1 \u2192 Sort ?u.7791562) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relator.RightTotal.rel_forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7791687) (R : \u2115 \u2192 ?\u03b2 \u2192 Prop) (eq' : ?\u03b2 \u2192 ?\u03b2 \u2192 Prop) (c : ?\u03b2) (he : (R \u21d2 R \u21d2 Iff) Eq eq') (s : R (gcd a b) c) (s : R 1 c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relator.left_unique_of_rel_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : ?\u03b2) (\u03b2 : Type ?u.7791776) (r : \u2115 \u2192 ?\u03b2 \u2192 Prop) (h : Relator.LeftUnique r) (e : flip r n (gcd a b)) (e : flip r n 1) (e : \u03b2) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relator.LeftUnique.flip<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : Reflexive Coprime) (hr : a \u2260 b \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Reflexive.rel_of_ne_imp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (hr' : Reflexive Coprime) (h : \u2200 (x y : \u2115), r x y \u2192 Coprime x y) (hxy : Relation.ReflGen r a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relation.reflGen_minimal<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (hr' : Transitive Coprime) (h : \u2200 (x y : \u2115), r x y \u2192 Coprime x y) (hxy : Relation.TransGen r a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relation.transGen_minimal<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (hr\u2081 : Reflexive Coprime) (hr\u2082 : Transitive Coprime) (h : \u2200 (x y : \u2115), r x y \u2192 Coprime x y) (hxy : Relation.ReflTransGen r a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relation.reflTransGen_minimal<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r' : \u2115 \u2192 \u2115 \u2192 Prop) (hr : Equivalence Coprime) (h : \u2200 (a b : \u2115), r' a b \u2192 Coprime a b) (t : Relation.Join r' a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relation.join_of_equivalence<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r' : \u2115 \u2192 \u2115 \u2192 Prop) (hr : Reflexive Coprime) (ht : Transitive Coprime) (h : \u2200 (a b : \u2115), r' a b \u2192 Coprime a b) (h' : Relation.ReflTransGen r' a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relation.reflTransGen_of_transitive_reflexive<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r' : \u2115 \u2192 \u2115 \u2192 Prop) (hr : Equivalence Coprime) (y : \u2200 (a b : \u2115), r' a b \u2192 Coprime a b) (y : Relation.ReflTransGen r' a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Relation.reflTransGen_of_equivalence<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7797078) (f : \u2115 \u21aa ?\u03b2) (x : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Embedding.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (f : \u2115 \u2192 \u2115) (n : \u2115) (Hinj : Function.Injective f) (y : f^[n] (gcd a b) = f^[n] 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective.iterate<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (hr : Pairwise r) (h : \u2200 \u2983i j : \u2115\u2984, r i j \u2192 Coprime i j) (d : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Pairwise.mono<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (h : Pairwise r) (d : \u00acr (gcd a b) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Pairwise.eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (h : \u2200 (a b : \u2115), Coprime a b) (s : a \u2208 s) (s : b \u2208 s) (s : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.pairwise_of_forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : Set \u2115) (h : Set.Pairwise s r) (hrp : Set.Pairwise s fun \u2983a b\u2984 => r a b \u2192 Coprime a b) (x : a \u2208 s) (x : b \u2208 s) (x : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.imp_on<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : Set \u2115) (h : Set.Pairwise s r) (hpq : \u2200 \u2983a b : \u2115\u2984, r a b \u2192 Coprime a b) (r : a \u2208 s) (r : b \u2208 s) (r : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.imp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : Set \u2115) (hs : Set.Pairwise s r) (ha : gcd a b \u2208 s) (hb : 1 \u2208 s) (h : \u00acr (gcd a b) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.Pairwise.eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (h : Pairwise Coprime) (d : a \u2208 s) (d : b \u2208 s) (d : a \u2260 b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Pairwise.set_pairwise<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h\u2081 : HEq (gcd a) (@OfNat.ofNat \u2115 1)) (h\u2082 : HEq b (instOfNatNat 1)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply congr_heq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : Fact (Coprime a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Fact.elim; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : \u00acCoprime a b \u2192 False) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply by_contradiction; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : Prop) (hpq : p \u2192 Coprime a b) (hnpq : \u00acp \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply by_cases<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : \u00ac\u00acCoprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply of_not_not; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : Prop) (x : \u00ac(Coprime a b \u2192 n)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply of_not_imp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Prop) (g : \u00acCoprime a b \u2192 s) (g : \u00acs) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Not.imp_symm<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : Prop) (x : Prop) (c : Prop) (h : d \u2228 x \u2228 c) (ha : d \u2192 Coprime a b) (hb : x \u2192 Coprime a b) (hc : c \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Or.elim3<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : Prop) (c : \u00acCoprime a b \u2192 \u00ace) (c : e) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.mtr<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : Prop) (e : (Coprime a b \u2192 w) \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply peirce<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : Coprime a b \u2192 Prop) (m : Exists p) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Exists.fst<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Sort ?u.7807067) (p : ?\u03b1 \u2192 Prop) (P : (x : ?\u03b1) \u2192 ?p x \u2192 Prop) (r : \u2203 x, \u2203 (h : p x), P x h) (r : \u2200 (a_1 : \u03b1) (h : p a_1), P a_1 h \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply BEx.elim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : \u2115 \u2192 Prop) (q : \u2115 \u2192 Prop) (H : \u2200 (x : \u2115), p x \u2192 q x) (h\u2081 : \u2200 (x : \u2115), q x \u2192 Coprime a x) (h : p b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply BAll.imp_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (x : \u2115), Coprime a x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply ball_of_forall; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : \u2115 \u2192 Prop) (H : \u2200 (x : \u2115), p x) (h : \u2200 (x : \u2115), p x \u2192 Coprime a x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply forall_of_ball<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7817452) (e : \u2115 \u2243 ?\u03b2) (n : e (gcd a b) = e 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Equiv.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (o : Ordering) (s : Ordering.Compares o (gcd a b) 1) (s : gcd a b \u2264 1) (s : 1 \u2264 gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Ordering.Compares.le_antisymm<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2\u2081 : Type ?u.7844970) (e : Equiv.Perm ?\u03b2\u2081) (w : ?\u03b2\u2081) (h : (Equiv.Perm.prodExtendRight 1 e) (gcd a b, w) \u2260 (gcd a b, w)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Equiv.Perm.eq_of_prodExtendRight_ne<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : gcd a b = 1) (r : OfNat \u2115 1 \u2192 OfNat \u2115 1 \u2192 Prop) (ha : Acc r t) (ih : \u2200 (b_1 : OfNat \u2115 1), 1 \u2260 1 \u2192 gcd a b = 1 \u2192 \u2203 c, r c b_1 \u2227 gcd a b = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Acc.induction_bot'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : \u2115) (r : \u2115 \u2192 \u2115 \u2192 Prop) (ha : Acc r t) (ih : \u2200 (b_1 : \u2115), b_1 \u2260 b \u2192 Coprime a b_1 \u2192 \u2203 c, r c b_1 \u2227 Coprime a c) (n : Coprime a t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Acc.induction_bot<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : OfNat \u2115 1 \u2192 OfNat \u2115 1 \u2192 Prop) (hwf : WellFounded r) (ih : \u2200 (b_1 : OfNat \u2115 1), 1 \u2260 1 \u2192 gcd a b = 1 \u2192 \u2203 c, r c b_1 \u2227 gcd a b = 1) (t : gcd a b = 1) (t : OfNat \u2115 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply WellFounded.induction_bot'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (r : \u2115 \u2192 \u2115 \u2192 Prop) (hwf : WellFounded r) (ih : \u2200 (b_1 : \u2115), b_1 \u2260 b \u2192 Coprime a b_1 \u2192 \u2203 c, r c b_1 \u2227 Coprime a c) (c : Coprime a g) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply WellFounded.induction_bot<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (ha : IsMin 1) (h : gcd a b \u2264 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsMin.eq_of_le<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (ha : IsMin (gcd a b)) (h : 1 \u2264 gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsMin.eq_of_ge<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (ha : IsMax (gcd a b)) (h : gcd a b \u2264 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsMax.eq_of_le<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (ha : IsMax 1) (h : 1 \u2264 gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsMax.eq_of_ge<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7863273) (f : \u2115 \u2192 ?\u03b2) (hf : Function.Bijective f) (y : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Bijective.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Sort ?u.7863591) (\u03b2 : Sort ?u.7863592) (f : ?\u03b1 \u2192 ?\u03b2) (g : \u2115 \u2192 ?\u03b1) (I : Function.Injective (f \u2218 g)) (t : g (gcd a b) = g 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective.of_comp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7863653) (\u03b3 : Sort ?u.7863654) (f : \u2115 \u2192 ?\u03b2) (g : ?\u03b3 \u2192 \u2115) (I : Function.Injective (f \u2218 g)) (hg : Function.Surjective g) (z : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective.of_comp_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7864722) (f : \u2115 \u2192 ?\u03b2) (g : ?\u03b2 \u2192 Option \u2115) (H : Function.IsPartialInv f g) (g : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.injective_of_isPartialInv<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Type ?u.7864751) (f : ?\u03b1 \u2192 \u2115) (g : \u2115 \u2192 Option ?\u03b1) (d : ?\u03b1) (H : Function.IsPartialInv f g) (h\u2081 : d \u2208 g (gcd a b)) (h\u2082 : d \u2208 g 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.injective_of_isPartialInv_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7865061) (f : \u2115 \u2192 ?\u03b2) (g : ?\u03b2 \u2192 \u2115) (h : Function.RightInverse f g) (v : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.RightInverse.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Sort ?u.7865871) (f : ?\u03b1 \u2192 \u2115) (h : Function.Surjective ?f) (w : Function.surjInv h (gcd a b) = Function.surjInv h 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.injective_surjInv<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (f : (_ : \u2115) \u00d7' \u2115 \u2192 \u2115) (e : Function.update f { fst := a, snd := b }) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.update_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (f : \u2115 \u2192 \u2115) (h : Function.Involutive f) (r : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Involutive.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.7874718) (\u03b3 : Sort ?u.7874719) (f : \u2115 \u2192 ?\u03b2 \u2192 ?\u03b3) (t : ?\u03b2) (hf : Function.Injective2 f) (z : (fun a => f a t) (gcd a b) = (fun a => f a t) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective2.left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : ?\u03b1) (\u03b1 : Sort ?u.7874750) (\u03b3 : Sort ?u.7874752) (f : ?\u03b1 \u2192 \u2115 \u2192 ?\u03b3) (hf : Function.Injective2 f) (v : f g (gcd a b) = f g 1) (v : \u03b1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective2.right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : \u2115) (h : 1 \u2a7f w) (v : gcd a b \u2208 Set.Ico 1 w) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply WCovBy.Ico_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (h : g \u2a7f 1) (s : gcd a b \u2208 Set.Ioc g 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply WCovBy.Ioc_subset<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (ha : gcd a b \u22d6 c) (hb : 1 \u22d6 c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply CovBy.unique_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (hb : g \u22d6 gcd a b) (hc : g \u22d6 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply CovBy.unique_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (c : \u2115) (hab : n \u22d6 1) (hbc : 1 \u22d6 c) (hax : n < gcd a b) (hxc : gcd a b < c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply CovBy.eq_of_between<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (l : \u2115 \u2192 \u2115) (l' : \u2115 \u2192 \u2115) (gc : GaloisConnection l (gcd a)) (gc' : GaloisConnection l' fun {b} => 1) (hl : \u2200 (a : \u2115), l a = l' a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply GaloisConnection.u_unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (u : \u2115 \u2192 \u2115) (u' : \u2115 \u2192 \u2115) (gc : GaloisConnection (gcd a) u) (gc' : GaloisConnection (fun {b} => 1) u') (hu : \u2200 (b : \u2115), u b = u' b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply GaloisConnection.l_unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : Set \u2115) (hs : IsAntichain r s) (ha : gcd a b \u2208 s) (hb : 1 \u2208 s) (h : r (gcd a b) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsAntichain.eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : Set \u2115) (hs : IsAntichain r s) (ha : gcd a b \u2208 s) (hb : 1 \u2208 s) (h : r 1 (gcd a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsAntichain.eq'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : Set \u2115) (c : \u2115) (hs : IsStrongAntichain r s) (ha : gcd a b \u2208 s) (hb : 1 \u2208 s) (hac : r (gcd a b) c) (hbc : r 1 c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsStrongAntichain.eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : \u2200 (x : \u2115), (\u2200 y < x, Coprime a y) \u2192 Coprime a x) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply WellFoundedLT.induction; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (z : \u2191(gcd a b) = \u21911) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply WithBot.coe_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (z : \u2191(gcd a b) = \u21911) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply WithTop.coe_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : \u2115) (h\u2081 : gcd a b \u2293 t = 1 \u2293 t) (h\u2082 : gcd a b \u2294 t = 1 \u2294 t) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_inf_eq_sup_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : \u2115) (hP : \u2200 (x : \u2115), Monotone (Coprime x)) (t : d \u2264 b) (t : \u2200 (x : \u2115), Coprime x d) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Monotone.forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : \u2115) (hP : \u2200 (x : \u2115), Antitone (Coprime x)) (n : b \u2264 v) (n : \u2200 (x : \u2115), Coprime x v) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Antitone.forall<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : \u2115) (s : Set \u2115) (hP : \u2200 x \u2208 s, Monotone (Coprime x)) (w : s \u2264 b) (w : \u2200 x \u2208 s, Coprime x s) (w : a \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Monotone.ball<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (w : \u2115) (hP : \u2200 x \u2208 s, Antitone (Coprime x)) (d : b \u2264 w) (d : \u2200 x \u2208 s, Coprime x w) (d : a \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Antitone.ball<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : 1 \u2264 gcd a b) (g : gcd a b \u2264 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply ge_antisymm; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : gcd a b \u2264 1) (hba : \u00acgcd a b < 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_le_of_not_lt<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hab : 1 \u2264 gcd a b) (hba : \u00ac1 < gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_ge_of_not_gt<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H : \u2200 (c : \u2115), c \u2264 gcd a b \u2194 c \u2264 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_forall_le_iff; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (H : \u2200 (c : \u2115), gcd a b \u2264 c \u2194 1 \u2264 c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_forall_ge_iff; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (c : \u2115), c < gcd a b \u2194 c < 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_forall_lt_iff; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (c : \u2115), gcd a b < c \u2194 1 < c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_forall_gt_iff; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7974232) (f : \u2115 \u2192 ?\u03b2) (h : \u2200 (x y : \u2115), x < y \u2192 f x \u2260 f y) (n : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply injective_of_lt_imp_ne<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.7998701) (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : ?\u03b2 \u2192 ?\u03b2 \u2192 Prop) (f : ?r \u21aar ?s) (m : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply RelEmbedding.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Type ?u.8000197) (r : \u2115 \u2192 \u2115 \u2192 Prop) (s : ?\u03b2 \u2192 ?\u03b2 \u2192 Prop) (e : ?r \u2243r ?s) (d : e (gcd a b) = e 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply RelIso.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (Ha : IsLeast s (gcd a b)) (Hb : IsLeast s 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsLeast.unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (Ha : IsGreatest s (gcd a b)) (Hb : IsGreatest s 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsGreatest.unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (Ha : IsLUB s (gcd a b)) (Hb : IsLUB s 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsLUB.unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (Ha : IsGLB s (gcd a b)) (Hb : IsGLB s 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsGLB.unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Set \u2115) (n : \u2115) (g : \u2115) (Ha : IsGLB s n) (Hb : IsLUB s g) (hab : g \u2264 n) (x : gcd a b \u2208 s) (x : 1 \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Set.subsingleton_of_isLUB_le_isGLB<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (M : Type ?u.8059025) (\u03bc : ?M \u2192 \u2115 \u2192 \u2115) (m : ?M) (h : Contravariant M \u2115 \u03bc Eq) (y : flip Eq (\u03bc m 1) (\u03bc m (gcd a b))) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Contravariant.flip<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k\u2081 : \u2115) (k\u2082 : \u2115) (hp\u2081 : _root_.Prime (gcd a b)) (hp\u2082 : _root_.Prime 1) (hk\u2081 : 0 < k\u2081) (h : gcd a b ^ k\u2081 = 1 ^ k\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_prime_pow_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (k\u2081 : \u2115) (k\u2082 : \u2115) (hp\u2081 : _root_.Prime (gcd a b)) (hp\u2082 : _root_.Prime 1) (hk\u2081 : 0 < k\u2082) (h : gcd a b ^ k\u2081 = 1 ^ k\u2082) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_prime_pow_eq'<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Associates.mk (gcd a b) = Associates.mk 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Associates.mk_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : 0 = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_zero_eq_one; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : gcd a b \u2223 1) (x : 1 \u2223 gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply dvd_antisymm; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : 1 \u2223 gcd a b) (e : gcd a b \u2223 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply dvd_antisymm'; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (c : \u2115), gcd a b \u2223 c \u2194 1 \u2223 c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_forall_dvd; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (c : \u2115), c \u2223 gcd a b \u2194 c \u2223 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_of_forall_dvd'; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : MulOpposite.op (gcd a b) = MulOpposite.op 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply MulOpposite.op_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : \u2115) (ha : MulLECancellable w) (s : (fun x => w * x) (gcd a b) = (fun x => w * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply MulLECancellable.isLeftRegular<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (ca : \u2200 (b : \u2115), Commute g b) (h : IsLeftRegular g) (y : (fun x => x * g) (gcd a b) = (fun x => x * g) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsLeftRegular.right_of_commute<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (ca : \u2200 (b : \u2115), Commute c b) (h : IsRightRegular c) (n : (fun x => c * x) (gcd a b) = (fun x => c * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsRightRegular.left_of_commute<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (t : \u2115) (lra : IsLeftRegular n) (lrb : IsLeftRegular t) (r : (fun x => n * t * x) (gcd a b) = (fun x => n * t * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsLeftRegular.mul<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : \u2115) (s : \u2115) (rra : IsRightRegular y) (rrb : IsRightRegular s) (e : (fun x => x * (y * s)) (gcd a b) = (fun x => x * (y * s)) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsRightRegular.mul<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (t : \u2115) (ab : IsLeftRegular (n * t)) (d : (fun x => t * x) (gcd a b) = (fun x => t * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsLeftRegular.of_mul<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : \u2115) (v : \u2115) (ab : IsRightRegular (v * w)) (d : (fun x => x * v) (gcd a b) = (fun x => x * v) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsRightRegular.of_mul<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : \u2115) (n : \u2115) (h : n * t = 1) (g : (fun x => t * x) (gcd a b) = (fun x => t * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply isLeftRegular_of_mul_eq_one<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115) (w : \u2115) (h : r * w = 1) (n : (fun x => x * r) (gcd a b) = (fun x => x * r) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply isRightRegular_of_mul_eq_one<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : \u2115) (ha : v \u2260 0) (h : v * gcd a b = v * 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply mul_left_cancel\u2080<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : \u2115) (ha : t \u2260 0) (y : (fun x => t * x) (gcd a b) = (fun x => t * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply mul_right_injective\u2080<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : \u2115) (hb : n \u2260 0) (h : gcd a b * n = 1 * n) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply mul_right_cancel\u2080<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (hb : g \u2260 0) (t : (fun a => a * g) (gcd a b) = (fun a => a * g) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply mul_left_injective\u2080<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (h\u2081 : c \u2264 gcd a b) (h\u2082 : c \u2264 1) (g : gcd a b - c = 1 - c) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply tsub_inj_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (hab : AddLECancellable (x - gcd a b)) (h\u2081 : gcd a b \u2264 x) (h\u2082 : 1 \u2264 x) (h\u2083 : x - gcd a b = x - 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply AddLECancellable.tsub_inj_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (h\u2081 : gcd a b \u2264 c) (h\u2082 : 1 \u2264 c) (h\u2083 : c - gcd a b = c - 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply tsub_inj_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : \u2115) (ha : gcd a b \u2264 1) (hb : v \u2264 1) (hab : 1 \u2264 gcd a b * v) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_one_of_one_le_mul_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : \u2115) (ha : 1 \u2264 gcd a b) (hb : 1 \u2264 t) (hab : gcd a b * t \u2264 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_one_of_mul_le_one_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (e : \u2115) (ha : e \u2264 1) (hb : gcd a b \u2264 1) (hab : 1 \u2264 e * gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_one_of_one_le_mul_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (ha : 1 \u2264 x) (hb : 1 \u2264 gcd a b) (hab : x * gcd a b \u2264 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_one_of_mul_le_one_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : \u2115) (ha : MulLECancellable c) (w : (fun x => c * x) (gcd a b) = (fun x => c * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply MulLECancellable.Injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (d : \u2115) (ha : MulLECancellable d) (t : (fun x => x * d) (gcd a b) = (fun x => x * d) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply MulLECancellable.injective_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : \u2115) (h : gcd a b * v = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_one_of_mul_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (h : x * gcd a b = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply eq_one_of_mul_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : \u2115) (h : IsUnit s) (m : s * gcd a b = s * 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsUnit.mul_left_cancel<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2115) (h : IsUnit m) (z : gcd a b * m = 1 * m) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsUnit.mul_right_cancel<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : \u2115) (h : IsUnit r) (s : (fun x => r * x) (gcd a b) = (fun x => r * x) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsUnit.mul_right_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (g : \u2115) (h : IsUnit g) (m : (fun x => x * g) (gcd a b) = (fun x => x * g) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply IsUnit.mul_left_injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (t : \u2115) (hba : gcd a b * t = 1) (hac : t * 1 = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply left_inv_eq_right_inv<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : Pi.mulSingle { fst := a, snd := b }) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Pi.mulSingle_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (hy : x * gcd a b = 1) (hz : x * 1 = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply inv_unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Multiset \u2115) (w : \u2200 x \u2208 s, 1 \u2264 x) (w : Multiset.prod s = 1) (w : gcd a b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Multiset.all_one_of_le_one_le_of_prod_eq_one<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : Finset \u2115) (hc : s.card \u2264 1) (h : (Finset.prod s fun x => gcd a x) = 1) (z : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.eq_of_card_le_one_of_prod_eq<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : \u2115) (s : Finset \u2115) (hp : (Finset.prod s fun x => gcd a x) = 1) (h1 : \u2200 x \u2208 s, x \u2260 x \u2192 gcd a x = 1) (e : b \u2208 s) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Finset.eq_one_of_prod_eq_one<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : Functor.Const.run (gcd a b) = Functor.Const.run 1) (\u03b2 : Type ?u.8351459) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Functor.Const.ext<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (n : divisors (gcd a b) = divisors 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.divisors_injective; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.8416632) (\u03c6 : Sort ?u.8416631) (g : ?\u03b2 \u2192 ?\u03c6) (f : \u2115 \u2192 ?\u03b2) (hg : Function.Injective g) (hf : Function.Injective f) (r : (g \u2218 f) (gcd a b) = (g \u2218 f) 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.Injective.comp<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.8416731) (g : ?\u03b2 \u2192 \u2115) (f : \u2115 \u2192 ?\u03b2) (r : Function.LeftInverse g f) (r : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.LeftInverse.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b2 : Sort ?u.8416761) (f : \u2115 \u2192 ?\u03b2) (c : Function.HasLeftInverse f) (c : f (gcd a b) = f 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.HasLeftInverse.injective<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : id (gcd a b) = id 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Function.injective_id; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : Prop) (q : Prop) (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 Coprime a b) (z : p) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Implies.trans<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (w : \u2115) (h\u2081 : Coprime a w) (h\u2082 : w = b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply trans_rel_left<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (s : \u2115) (h\u2081 : a = s) (h\u2082 : Coprime s b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply trans_rel_right<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : HEq (Coprime a b) True) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply of_heq_true; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (\u03b1 : Sort ?u.8420540) (p : ?\u03b1 \u2192 Prop) (h\u2082 : \u2203! x, p x) (h\u2081 : \u2200 (x : \u03b1), p x \u2192 (\u2200 (y : \u03b1), p y \u2192 y = x) \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply ExistsUnique.elim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (p : \u2115 \u2192 Prop) (h : \u2203! x, p x) (py\u2081 : p (gcd a b)) (py\u2082 : p 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply ExistsUnique.unique<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (x : AsTrue (Coprime a b)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply AsTrue.get; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (x : \u2115), gcd a x = 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply let_body_eq; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : Equivalence fun {b} => Coprime a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Equivalence.reflexive; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : Equivalence Coprime) (m : Coprime b a) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Equivalence.symmetric<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : \u2115) (h : Equivalence Coprime) (c : Coprime a y) (c : Coprime y b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Equivalence.transitive<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : decide (Coprime a b) = true) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Bool.of_decide_true; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (v : bit0 (gcd a b) = bit0 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.bit0_inj; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (c : bit1 (gcd a b) = bit1 1) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.bit1_inj; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (h : \u2200 (n : \u2115), (\u2200 m < n, Coprime a m) \u2192 Coprime a n) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.strong_induction_on; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (hz : Coprime a 0) (hi : \u2200 (n : \u2115), (\u2200 m \u2264 n, Coprime a m) \u2192 Coprime a (succ n)) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Nat.case_strong_induction_on<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (y : \u2124) (e : \u2124) (h : y \u2264 e) (h' : \u2200 (n : \u2115), y + \u2191n = e \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Int.le.elim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (m : \u2124) (m : \u2124) (h : m < m) (h' : \u2200 (n : \u2115), m + \u2191(succ n) = m \u2192 Coprime a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply Int.lt.elim<;> assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\nexample {a b : \u2115} (r : gcd a b \u2264 1) (r : 1 \u2264 gcd a b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow):= by\n  have hab : a.Coprime b := by apply le_antisymm; assumption\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n#align nat.disjoint_divisors_filter_prime_pow Nat.disjoint_divisors_filter_isPrimePow\n\ntheorem IsPrimePow.two_le : \u2200 {n : \u2115}, IsPrimePow n \u2192 2 \u2264 n\n  | 0, h => (not_isPrimePow_zero h).elim\n  | 1, h => (not_isPrimePow_one h).elim\n  | _n + 2, _ => le_add_self\n#align is_prime_pow.two_le IsPrimePow.two_le\n\ntheorem IsPrimePow.pos {n : \u2115} (hn : IsPrimePow n) : 0 < n :=\n  pos_of_gt hn.two_le\n#align is_prime_pow.pos IsPrimePow.pos\n\ntheorem IsPrimePow.one_lt {n : \u2115} (h : IsPrimePow n) : 1 < n :=\n  h.two_le\n#align is_prime_pow.one_lt IsPrimePow.one_lt\n\nend Nat"}
